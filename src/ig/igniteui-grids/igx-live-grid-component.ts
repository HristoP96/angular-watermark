import { Component, EventEmitter, Output, ViewContainerRef, ComponentFactoryResolver, Injector, NgZone, AfterContentInit, OnInit, Renderer2, ViewChild, ElementRef, Inject, forwardRef, Input, ChangeDetectionStrategy, ContentChildren, QueryList } from '@angular/core';
import { IgRect } from 'igniteui-core/IgRect'
import { IgSize } from 'igniteui-core/IgSize'
import { IgPoint } from 'igniteui-core/IgPoint'
import { IgDataTemplate } from 'igniteui-core/IgDataTemplate'
import { IgxSectionHeaderComponent } from './igx-section-header-component';
import { IgxSummaryRowRootComponent } from './igx-summary-row-root-component';
import { IgxSummaryRowSectionComponent } from './igx-summary-row-section-component';
import { IgxColumnWidth } from './igx-column-width';
import { ColumnWidth as ColumnWidth_internal } from './ColumnWidth';
import { HeaderClickAction, HeaderClickAction_$type } from './HeaderClickAction';
import { ColumnShowingAnimationMode, ColumnShowingAnimationMode_$type } from './ColumnShowingAnimationMode';
import { ColumnPropertyUpdatingAnimationMode, ColumnPropertyUpdatingAnimationMode_$type } from './ColumnPropertyUpdatingAnimationMode';
import { CellDataLoadedAnimationMode, CellDataLoadedAnimationMode_$type } from './CellDataLoadedAnimationMode';
import { RowSelectionAnimationMode, RowSelectionAnimationMode_$type } from './RowSelectionAnimationMode';
import { ColumnMovingAnimationMode, ColumnMovingAnimationMode_$type } from './ColumnMovingAnimationMode';
import { ColumnHidingAnimationMode, ColumnHidingAnimationMode_$type } from './ColumnHidingAnimationMode';
import { CellSelectionAnimationMode, CellSelectionAnimationMode_$type } from './CellSelectionAnimationMode';
import { ColumnExchangingAnimationMode, ColumnExchangingAnimationMode_$type } from './ColumnExchangingAnimationMode';
import { GridSelectionMode, GridSelectionMode_$type } from './GridSelectionMode';
import { GridActivationMode, GridActivationMode_$type } from './GridActivationMode';
import { GridSelectionBehavior, GridSelectionBehavior_$type } from './GridSelectionBehavior';
import { IgxGridCellEventArgs } from './igx-grid-cell-event-args';
import { IgxGridColumnsAutoGeneratedEventArgs } from './igx-grid-columns-auto-generated-event-args';
import { IgxGridSelectedItemsChangedEventArgs } from './igx-grid-selected-items-changed-event-args';
import { IgxGridSelectedKeysChangedEventArgs } from './igx-grid-selected-keys-changed-event-args';
import { IgxGridSelectedCellsChangedEventArgs } from './igx-grid-selected-cells-changed-event-args';
import { IgxGridSelectedCellRangesChangedEventArgs } from './igx-grid-selected-cell-ranges-changed-event-args';
import { IgxGridSortDescriptionsChangedEventArgs } from './igx-grid-sort-descriptions-changed-event-args';
import { IgxGridGroupDescriptionsChangedEventArgs } from './igx-grid-group-descriptions-changed-event-args';
import { Grid } from "./Grid";
import { ensureEnum, ensureBool, CollectionAdapter, initializePropertiesFromCss, NamePatcher, stringToBrush, brushToString, toSpinal } from "igniteui-core/componentUtil";
import { Thickness } from "igniteui-core/Thickness";
import { AngularRenderer, AngularWrapper } from 'igniteui-core/angular-renderer';
import { Column } from './Column';
import { IgxColumnComponent } from './igx-column-component';
import { DataGridCellLayoutPanel } from './DataGridCellLayoutPanel';
import { Base } from 'igniteui-core/type';
import { DomWrapper } from 'igniteui-core/dom';
import { GridExternalWrapper } from './GridExternalWrapper';
import { BrowserTickProvider } from './BrowserTickProvider';
import { BrowserPixelConverter } from './BrowserPixelConverter';
import { DataGridPresenterManager } from './DataGridPresenterManager';
import { DataGridViewportManager } from './DataGridViewportManager';
import { DataGridDelayedExecutionManager } from './DataGridDelayedExecutionManager';
import { DataGridPropertySetter } from './DataGridPropertySetter';
import { IgxGridColumnCollection } from './igx-grid-column-collection';
import { SyncableObservableCollection$1 } from 'igniteui-core/SyncableObservableCollection$1';
import { SyncableObservableCollection$2 } from 'igniteui-core/SyncableObservableCollection$2';
import { NotifyCollectionChangedEventArgs } from 'igniteui-core/NotifyCollectionChangedEventArgs';
import { NotifyCollectionChangedAction } from 'igniteui-core/NotifyCollectionChangedAction';
import { Scroller } from 'igniteui-core/Scroller';
import { ScrollbarStyle } from 'igniteui-core/ScrollbarStyle';
import { Dragger } from 'igniteui-grids/Dragger';
import { LiveGridStylingDefaults } from './LiveGridStylingDefaults';
import { delegateCombine, delegateRemove } from 'igniteui-core/type';
import { FontInfo } from 'igniteui-core/FontInfo';
import { IgxColumnSortDescriptionCollection } from './igx-column-sort-description-collection';
import { IgxColumnGroupDescriptionCollection } from './igx-column-group-description-collection';
import { IgxFilterExpressionCollection } from 'igniteui-core/igx-filter-expression-collection';
import { IgxColumnSummaryDescriptionCollection } from './igx-column-summary-description-collection';
import { IgxGridSelectedItemsCollection } from 'igniteui-grids/igx-grid-selected-items-collection';
import { IgxGridSelectedKeysCollection } from 'igniteui-grids/igx-grid-selected-keys-collection';
import { IgxGridSelectedCellsCollection } from 'igniteui-grids/igx-grid-selected-cells-collection';
import { IgxGridSelectedCellRangesCollection } from 'igniteui-grids/igx-grid-selected-cell-ranges-collection';
import { GridSelectedItemsCollection as GridSelectedItemsCollection_internal } from 'igniteui-grids/GridSelectedItemsCollection';
import { GridSelectedKeysCollection as GridSelectedKeysCollection_internal } from 'igniteui-grids/GridSelectedKeysCollection';
import { GridSelectedCellsCollection as GridSelectedCellsCollection_internal } from 'igniteui-grids/GridSelectedCellsCollection';
import { GridSelectedCellRangesCollection as GridSelectedCellRangesCollection_internal } from 'igniteui-grids/GridSelectedCellRangesCollection';
import { IgxPrimaryKeyValue } from 'igniteui-grids/igx-primary-key-value';
import { PrimaryKeyValue } from 'igniteui-grids/PrimaryKeyValue';
import { IgxCellKey } from 'igniteui-grids/igx-cell-key';
import { CellKey } from 'igniteui-grids/CellKey';
import { IgxCellRange } from 'igniteui-grids/igx-cell-range';
import { CellRange } from 'igniteui-grids/CellRange';
import { IgxGridFilterExpressionsEventArgs } from './igx-grid-filter-expressions-event-args';
import { GridColumnCollection as GridColumnCollection_internal } from './GridColumnCollection';
import { ResponsiveStatesCollection as ResponsiveStatesCollection_internal } from './ResponsiveStatesCollection';
import { IgxResponsiveStatesCollection } from './igx-responsive-states-collection';
import { IgxResponsiveState } from './igx-responsive-state';
import { ResponsiveState } from './ResponsiveState';
import { IgxGridAnimationSettings } from './igx-grid-animation-settings'; 
import { IgxRowSeparatorComponent } from './igx-row-separator-component';
import { IDataSource } from 'igniteui-core/IDataSource';
import { IgxGridCellPosition } from 'igniteui-grids/igx-grid-cell-position';
import { IgxGridActiveCellChangedEventArgs } from 'igniteui-grids/igx-grid-active-cell-changed-event-args';
import { IgxColumnHiddenChangedEventArgs } from 'igniteui-grids/igx-column-hidden-changed-event-args';
import { DataGridScrollerKeyboardListener } from 'igniteui-grids/DataGridScrollerKeyboardListener';
import { IgxCellInfo } from 'igniteui-grids/igx-cell-info';
import { IgxHeaderSeparatorComponent } from 'igniteui-grids/igx-header-separator-component';
import { IgxColumnResizingSeparatorComponent } from './igx-column-resizing-separator-component';
import { ColumnResizingMode, ColumnResizingMode_$type } from 'igniteui-grids/ColumnResizingMode';
import { ColumnResizingAnimationMode, ColumnResizingAnimationMode_$type } from 'igniteui-grids/ColumnResizingAnimationMode';
import { ColumnMovingMode, ColumnMovingMode_$type } from 'igniteui-grids/ColumnMovingMode';
import { IgxColumnMovingSeparatorComponent } from './igx-column-moving-separator-component';
import { SortIndicatorStyle, SortIndicatorStyle_$type } from 'igniteui-grids/SortIndicatorStyle';
import { DataSourceSectionHeaderDisplayMode, DataSourceSectionHeaderDisplayMode_$type } from 'igniteui-core/DataSourceSectionHeaderDisplayMode';
import { DataSourceSummaryScope, DataSourceSummaryScope_$type } from 'igniteui-core/DataSourceSummaryScope';
import { GroupSummaryDisplayMode, GroupSummaryDisplayMode_$type } from 'igniteui-grids/GroupSummaryDisplayMode';
import { ISummaryResult } from 'igniteui-core/ISummaryResult';
import { IgxPinnedAreaSeparatorComponent } from 'igniteui-grids/igx-pinned-area-separator-component';
import { PinnedPositions } from 'igniteui-grids/PinnedPositions';
import { fromRect } from 'igniteui-core/componentUtil';

export const IgxGridComponent_PROVIDERS = [];

let GridStylingDefaults = {};

@Component({
    selector: 'igx-live-grid',
    styles: [`:host {
		display: block;
	}`],
    template: `
    <ng-container #dynamicContent></ng-container>
  `,
    host: { 'class': 'ig-live-grid igx-live-grid' },
    providers: [],
    changeDetection: ChangeDetectionStrategy.OnPush
})
export class IgxLiveGridComponent implements OnInit, AfterContentInit {
    @ContentChildren(IgxColumnComponent) contentColumns: QueryList<IgxColumnComponent>;
    @ViewChild("dynamicContent", { read: ViewContainerRef, static: true }) _dynamicContent: ViewContainerRef;

    /**
	 * The columns actually present in the grid. Do not directly modify this array.
	 * This array's contents can be modified by causing Angular to reproject the child content.
	 * Or adding and removing columns from the manual columns collection on the columns property.
	 */
    combinedColumns: IgxColumnComponent[] = [];
	
    private _container: any;

    private _columns: IgxGridColumnCollection = null;

    private _disableManualColumnSync: boolean = false;
    private _ensureColumnsAreManual(): void {
        this._disableManualColumnSync = true;
        this._columnsAdapter.shiftContentToManual(this.columns, (i) => i.isFromMarkup = false);
        this._disableManualColumnSync = false;
    }

	/**
	 * A collection or manually added columns for the grid.
	*/
    get columns(): IgxGridColumnCollection {
        if (this._columns === null) {
            let coll = new IgxGridColumnCollection();
            let inner: SyncableObservableCollection$2<IgxColumnComponent, Column> = (<any>coll)._innerColl;
            inner.addListener((sender, e) => {
                if (this._disableManualColumnSync) {
                    return;
                }
                switch (e.action) {
                    case NotifyCollectionChangedAction.Add:
                        this._columnsAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Remove:
                        this._columnsAdapter.removeManualItemAt(e.oldStartingIndex);
                        break;
                    case NotifyCollectionChangedAction.Replace:
                        this._columnsAdapter.removeManualItemAt(e.oldStartingIndex);
                        this._columnsAdapter.insertManualItem(e.newStartingIndex, e.newItems.item(0));
                        break;
                    case NotifyCollectionChangedAction.Reset:
                        this._columnsAdapter.clearManualItems();
                        break;
                }
            });
            this._columns = coll;
        }
        return this._columns;
    }

    private _height: string;
    private _width: string;
    @Input()
    set height(value: string) {
        this._height = value;
        this._renderer.setStyle(this._elRef.element.nativeElement, "height", value);
        this.containerResized();
    }
    get height(): string {
        return this._height;
    }

    @Input()
    set width(value: string) {
        this._width = value;
        this._renderer.setStyle(this._elRef.element.nativeElement, "width", value);
        this.containerResized();
    }
    get width(): string {
        return this._width;
    }

    private _scrollerStyle: ScrollbarStyle = ScrollbarStyle.Fading;

    @Input()
    set scrollbarStyle(style: ScrollbarStyle) {
        this._scrollerStyle = style;
        if (this._scroller) {
            this._scroller.scrollbarStyle = this._scrollerStyle;
        }
    }
    get scrollbarStyle(): ScrollbarStyle {
        return this._scrollerStyle;
    }

    private _columnsAdapter: CollectionAdapter<IgxColumnComponent, Column> = null;

    protected createImplementation(): Grid {
        let test = Grid;
        return new Grid();
    }
    ngOnInit() {
    }
    protected _implementation: any;
    public get i(): Grid {
        return this._implementation;
    }
    private onImplementationCreated() {

    }

    constructor(
        private _renderer: Renderer2,
        private _elRef: ViewContainerRef,
        private _ngZone: NgZone,
        private _componentFactoryResolver: ComponentFactoryResolver,
        private _injector: Injector) {

        if ((this as any)._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }

        let useCanvas = false;

        this._zoneRunner = (act: () => void) => this._ngZone.run(act);

        this._container = _renderer.createElement("div");



        _renderer.appendChild(_elRef.element.nativeElement, this._container);
        _renderer.setStyle(this._container, "display", "block");
        _renderer.setStyle(this._container, "width", "100%");
        _renderer.setStyle(this._container, "height", "100%");
        _renderer.setStyle(this._container, "box-sizing", "border-box");
        var root: any;
        root = this._container;
        if (this._container.nativeElement != null) {
            root = this._container.nativeElement;
        }
        var ren: AngularRenderer = new AngularRenderer(
            root, this._renderer, window.document,
            this._ngZone,
            true,
            LiveGridStylingDefaults);

        this._wrapper = ren;
        this._implementation = new Grid();
        var grid = this.i;
        this._grid = grid;

        this._columnsAdapter = new CollectionAdapter<IgxColumnComponent, Column>(
            [],
            this.i.columns,
            this.combinedColumns,
            (c) => c.i,
            (i) => { 
                (<any>i)._provideRenderer(this._wrapper); 
                if (this._elRef && this._elRef.element.nativeElement.parentElement) { 
                    (i as any)._styling(this._elRef.element.nativeElement, this, this); 
                } 
            },
            (i) => { (<any>i)._provideRenderer(null); }
        );

        grid.externalGrid = new GridExternalWrapper(this);
        grid.tickProvider = new BrowserTickProvider(ren);
        grid.platformPixelConverter = new BrowserPixelConverter();

        this._contentLayout = new DataGridCellLayoutPanel(ren, new DataGridPresenterManager(this._grid, useCanvas), window.devicePixelRatio);
        grid.renderingEngine = this._contentLayout;
        grid.viewportManager = new DataGridViewportManager(this);
        grid.delayedExecutionManager = new DataGridDelayedExecutionManager(ren);
        grid.propertySetter = new DataGridPropertySetter();

        //grid.provideContainer(ren);

        let scroller = new Scroller();
        this._scroller = scroller;
        scroller.scrollbarStyle = this.scrollbarStyle;
        scroller.provideContainer(ren);
        this._content = <Element>(this._contentLayout.element.getNativeElement());
        scroller.keyboardListener = new DataGridScrollerKeyboardListener(grid);
        scroller.provideContent(new AngularWrapper(this._content, this._renderer, this._ngZone));
        scroller.onScrolling = () => this.onScroll();
        scroller.viewportWidth = this._container.clientWidth;
        scroller.viewportHeight = this._container.clientHeight;
        scroller.verticalTrackStartInset = this.headerHeight;

        grid.dragger = new Dragger();
        grid.dragger.provideContainer(ren);
        grid.dragger.viewportWidth = this._container.clientWidth;
        grid.dragger.viewportHeight = this._container.clientHeight;

        ren.addSizeWatcher(() => {
            this.containerResized();
        });

        // supports angular themes or custom properties set in CSS 
        //this._styling(_elRef.element.nativeElement, this);
    }

    private _focusScroller(): void {
        this._scroller.focus();
    }

    private _setDefaultCursor() {
        if (this._elRef.element.nativeElement.style.cursor !== "") {
            this._elRef.element.nativeElement.style.cursor = "";
        }
    }
    private _setResizeCursor() {
        if (this._elRef.element.nativeElement.style.cursor !== "col-resize") {
            this._elRef.element.nativeElement.style.cursor = "col-resize";
        }
    }
    private _setHandCursor() {
        if (this._elRef.element.nativeElement.style.cursor !== "grabbing") {
            this._elRef.element.nativeElement.style.cursor = "grabbing";
        }
    }

    private _scroller: Scroller = null;
    private _dragger: Dragger = null;

    private _wrapper: AngularRenderer = null;
    private _grid: Grid = null;

    private containerResized = function () {
        var width = this._container.clientWidth;
        var height = this._container.clientHeight;
        this._scroller.viewportWidth = width;
        this._scroller.viewportHeight = height;

        this._grid.dragger.viewportWidth = width;
        this._grid.dragger.viewportHeight = height;

        this._grid.sizeChanged(width, height);
        if (this._grid.model.actualVisibleRegion.isEmpty &&
            width > 0 && height > 0) {
            this._grid.setViewport(0, 0, width, height);
        }
        else {
            this.onScroll();
        }
    };

    private _insertExternalColumnAtIndex(index: number, column: IgxColumnComponent) {
        //let contentCount = this.contentColumns.length;
        let contentCount = this._columnsAdapter.actualContent.length;
        this.columns.insert(index - contentCount, column);
    }

    private _removeExternalColumn(column: IgxColumnComponent) {
        let ind = -1;
        for (let i = 0; i < this.columns.count; i++) {
            if (this.columns.item(i) === column) {
                ind = i;
                break;
            }
        }
        if (ind >= 0) {
            this.columns.removeAt(ind);
        }
    }

    ngAfterContentInit() {
        let prev = this._grid.columnPropertyUpdatingAnimationMode;
		this._grid.columnPropertyUpdatingAnimationMode = ColumnPropertyUpdatingAnimationMode.None;

        this._styling(this._elRef.element.nativeElement, this);		

		this._grid.columnPropertyUpdatingAnimationMode = prev;

        this._columnsAdapter.updateQuery(this.contentColumns);

         prev = this._grid.columnPropertyUpdatingAnimationMode;
		this._grid.columnPropertyUpdatingAnimationMode = ColumnPropertyUpdatingAnimationMode.None;
		for (let i = 0; i < this.actualColumns.count; i++) {
            let c = this.actualColumns.item(i);
            (c as any)._styling(this._elRef.element.nativeElement, this, this);
        }
		this._grid.columnPropertyUpdatingAnimationMode = prev;

        this._grid.itemsSource = this._dataSource;
    }

    public get actualDataSource(): IDataSource {
        return this.i.actualDataSource;
    }

    private _contentLayout: DataGridCellLayoutPanel;
    private _contentDiv: DomWrapper;
    private _useNativeScroll: boolean;
    private _content: Element;

    private refreshContentSize() {
        if (this._content != null) {
            var width = this._grid.model.absoluteWidth;
            var height = this._grid.model.absoluteHeight;

            if (this._scroller != null) {
                this._scroller.contentWidth = width;
                this._scroller.contentHeight = height;
            }
        }
    }

    onScroll() {
        let top = this._scroller.scrollTop;
        let left = this._scroller.scrollLeft;
        let width = this._scroller.viewportWidth;
        let height = this._scroller.viewportHeight;
        //console.log("top:" + top);
        this._grid.setViewport(left, top, left + width, top + height);
    }

    private _dataSource: any = null;
    @Input()
    set dataSource(value: any) {
        this._dataSource = value;
        if (this._grid != null) {
            this._grid.itemsSource = this._dataSource;
        }
    }
    get dataSource(): any {
        return this._dataSource;
    }

    forColumnsWithPropertyPath(propertyPath: string, callback: (column: IgxColumnComponent) => void) {
        for (let i = 0; i < this.i.actualColumns.count; i++) {
            let col: IgxColumnComponent = this.i.actualColumns.item(i).externalObject;
            if (col.propertyPath == propertyPath) {
                callback(col);
            }
        }
    }

    /**
     * Gets or sets the default column width to use if a column as no local width.
     * */
    public get defaultColumnWidth(): IgxColumnWidth {
        let ext = (this.i.defaultColumnWidth as any).externalObject;
        if (!ext) {
            ext = new IgxColumnWidth();
            (ext as any)._implementation = this.i.defaultColumnWidth;
        }
        return ext;
    }
    public set defaultColumnWidth(value: IgxColumnWidth) {
        if (typeof value == "string") {
            let int = ColumnWidth_internal.parse(value as string);
            let ext = new IgxColumnWidth();
            (ext as any)._implementation = int;
            value = ext;
        }
        this.i.defaultColumnWidth = value.i;
    }

    private _insetLeft: number = 0;
	/**
	 * Gets or sets the amount of left inset space to use around the grid content.
	*/
    get insetLeft(): number {
        return this._insetLeft;
    }
    set insetLeft(v: number) {
        this._insetLeft = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }

    private _insetTop: number = 0;
	/**
	 * Gets or sets the amount of top inset space to use around the grid content.
	*/
    get insetTop(): number {
        return this._insetTop;
    }
    set insetTop(v: number) {
        this._insetTop = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }

    private _insetRight: number = 0;
	/**
	 * Gets or sets the amount of right inset space to use around the grid content.
	*/
    get insetRight(): number {
        return this._insetLeft;
    }
    set insetRight(v: number) {
        this._insetRight = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }

    private _insetBottom: number = 0;
	/**
	 * Gets or sets the amount of bottom inset space to use around the grid content.
	*/
    get insetBottom(): number {
        return this._insetBottom;
    }
    set insetBottom(v: number) {
        this._insetBottom = +v;
        let inset = new Thickness(1, this._insetLeft, this._insetTop, this._insetRight, this._insetBottom);
        this.i.inset = inset;
    }

    	/**
	 * Gets or sets the type of column resizing to use.
	*/
	get columnResizingMode() : ColumnResizingMode {
		return this.i.columnResizingMode;
	}
	@Input()
	set columnResizingMode(v: ColumnResizingMode) {
		this.i.columnResizingMode = ensureEnum<ColumnResizingMode>(ColumnResizingMode_$type, v);
	}
	/**
	 * Gets or sets the type column moving to use.
	*/
	get columnMovingMode() : ColumnMovingMode {
		return this.i.columnMovingMode;
	}
	@Input()
	set columnMovingMode(v: ColumnMovingMode) {
		this.i.columnMovingMode = ensureEnum<ColumnMovingMode>(ColumnMovingMode_$type, v);
	}
	/**
	 * Gets or sets the header type used for sectioning off groups of rows.
	*/
	get sectionHeader() : IgxSectionHeaderComponent {
	                                        if (this.i.sectionHeader == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.sectionHeader as any).externalObject) {
	                                            let e = IgxSectionHeaderComponent._createFromInternal(this.i.sectionHeader);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.sectionHeader;
	                                            }
	                                            (this.i.sectionHeader as any).externalObject = e;
	                                        }
		return (this.i.sectionHeader as any).externalObject;
	}
	@Input()
	set sectionHeader(v: IgxSectionHeaderComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.sectionHeader = null : this.i.sectionHeader = v.i;
	}
	/**
	 * Gets or sets the cell definition used for summary rows at the root level.
	*/
	get summaryRowRoot() : IgxSummaryRowRootComponent {
	                                        if (this.i.summaryRowRoot == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.summaryRowRoot as any).externalObject) {
	                                            let e = IgxSummaryRowRootComponent._createFromInternal(this.i.summaryRowRoot);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.summaryRowRoot;
	                                            }
	                                            (this.i.summaryRowRoot as any).externalObject = e;
	                                        }
		return (this.i.summaryRowRoot as any).externalObject;
	}
	@Input()
	set summaryRowRoot(v: IgxSummaryRowRootComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.summaryRowRoot = null : this.i.summaryRowRoot = v.i;
	}
	/**
	 * Gets or sets the cell definition used for summary rows at the section level.
	*/
	get summaryRowSection() : IgxSummaryRowSectionComponent {
	                                        if (this.i.summaryRowSection == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.summaryRowSection as any).externalObject) {
	                                            let e = IgxSummaryRowSectionComponent._createFromInternal(this.i.summaryRowSection);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.summaryRowSection;
	                                            }
	                                            (this.i.summaryRowSection as any).externalObject = e;
	                                        }
		return (this.i.summaryRowSection as any).externalObject;
	}
	@Input()
	set summaryRowSection(v: IgxSummaryRowSectionComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.summaryRowSection = null : this.i.summaryRowSection = v.i;
	}
	/**
	 * Gets or sets the row seperator settings.
	*/
	get rowSeparator() : IgxRowSeparatorComponent {
	                                        if (this.i.rowSeparator == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.rowSeparator as any).externalObject) {
	                                            let e = IgxRowSeparatorComponent._createFromInternal(this.i.rowSeparator);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.rowSeparator;
	                                            }
	                                            (this.i.rowSeparator as any).externalObject = e;
	                                        }
		return (this.i.rowSeparator as any).externalObject;
	}
	@Input()
	set rowSeparator(v: IgxRowSeparatorComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.rowSeparator = null : this.i.rowSeparator = v.i;
	}
	/**
	 * Gets or sets the header seperator settings.
	*/
	get headerSeparator() : IgxHeaderSeparatorComponent {
	                                        if (this.i.headerSeparator == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.headerSeparator as any).externalObject) {
	                                            let e = IgxHeaderSeparatorComponent._createFromInternal(this.i.headerSeparator);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.headerSeparator;
	                                            }
	                                            (this.i.headerSeparator as any).externalObject = e;
	                                        }
		return (this.i.headerSeparator as any).externalObject;
	}
	@Input()
	set headerSeparator(v: IgxHeaderSeparatorComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.headerSeparator = null : this.i.headerSeparator = v.i;
	}
	/**
	 * Gets or sets the column resizing seperator settings.
	*/
	get columnResizingSeparator() : IgxColumnResizingSeparatorComponent {
	                                        if (this.i.columnResizingSeparator == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.columnResizingSeparator as any).externalObject) {
	                                            let e = IgxColumnResizingSeparatorComponent._createFromInternal(this.i.columnResizingSeparator);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.columnResizingSeparator;
	                                            }
	                                            (this.i.columnResizingSeparator as any).externalObject = e;
	                                        }
		return (this.i.columnResizingSeparator as any).externalObject;
	}
	@Input()
	set columnResizingSeparator(v: IgxColumnResizingSeparatorComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.columnResizingSeparator = null : this.i.columnResizingSeparator = v.i;
	}
	/**
	 * Gets or sets the column resizing seperator settings.
	*/
	get columnMovingSeparator() : IgxColumnMovingSeparatorComponent {
	                                        if (this.i.columnMovingSeparator == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.columnMovingSeparator as any).externalObject) {
	                                            let e = IgxColumnMovingSeparatorComponent._createFromInternal(this.i.columnMovingSeparator);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.columnMovingSeparator;
	                                            }
	                                            (this.i.columnMovingSeparator as any).externalObject = e;
	                                        }
		return (this.i.columnMovingSeparator as any).externalObject;
	}
	@Input()
	set columnMovingSeparator(v: IgxColumnMovingSeparatorComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.columnMovingSeparator = null : this.i.columnMovingSeparator = v.i;
	}
	/**
	 * Gets or sets the pinned area separator settings.
	*/
	get pinnedAreaSeparator() : IgxPinnedAreaSeparatorComponent {
	                                        if (this.i.pinnedAreaSeparator == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.pinnedAreaSeparator as any).externalObject) {
	                                            let e = IgxPinnedAreaSeparatorComponent._createFromInternal(this.i.pinnedAreaSeparator);
	                                            if (e) {
	                                                (e as any)._implementation = this.i.pinnedAreaSeparator;
	                                            }
	                                            (this.i.pinnedAreaSeparator as any).externalObject = e;
	                                        }
		return (this.i.pinnedAreaSeparator as any).externalObject;
	}
	@Input()
	set pinnedAreaSeparator(v: IgxPinnedAreaSeparatorComponent) {
	                                        if (v != null && this._stylingContainer && (v as any)._styling) (v as any)._styling(this._stylingContainer, this, this);
	
		v == null ? this.i.pinnedAreaSeparator = null : this.i.pinnedAreaSeparator = v.i;
	}
	/**
	 * Gets or sets the desired properties for the data source to load. If specified the data source may decide to constrain the properties it fetches to these properties and must make sure that at least those properties are loaded, rather than the default behavior for that data source.
	*/
	get dataSourceDesiredProperties() : string[] {
		return this.i.dataSourceDesiredProperties as string[];
	}
	@Input()
	set dataSourceDesiredProperties(v: string[]) {
		this.i.dataSourceDesiredProperties = v;
	}
	/**
	 * Gets or sets the height to use for the rows in the grid.
	*/
	get rowHeight() : number {
		return (this.i.rowHeight as number);
	}
	@Input()
	set rowHeight(v: number) {
		this.i.rowHeight = +v;
	}
	/**
	 * Gets or sets the default minimum width to use on all columns. Ignored if NaN.
	*/
	get defaultColumnMinWidth() : number {
		return (this.i.defaultColumnMinWidth as number);
	}
	@Input()
	set defaultColumnMinWidth(v: number) {
		this.i.defaultColumnMinWidth = +v;
	}
	/**
	 * Gets or sets the height to use for the header row.
	*/
	get headerHeight() : number {
		return (this.i.headerHeight as number);
	}
	@Input()
	set headerHeight(v: number) {
		this.i.headerHeight = +v;
	}
	/**
	 * Returns/sets the action to take when a column header is clicked.
	*/
	get headerClickAction() : HeaderClickAction {
		return this.i.headerClickAction;
	}
	@Input()
	set headerClickAction(v: HeaderClickAction) {
		this.i.headerClickAction = ensureEnum<HeaderClickAction>(HeaderClickAction_$type, v);
	}
	/**
	 * Configures whether or not the grid will autogenerate columns when the data source is set.
	*/
	get autoGenerateColumns() : boolean {
		return (this.i.autoGenerateColumns as boolean);
	}
	@Input()
	set autoGenerateColumns(v: boolean) {
		this.i.autoGenerateColumns = ensureBool(v);
	}
	/**
	 * Sets or gets the height to use for the row separators.
	*/
	get rowSeparatorHeight() : number {
		return (this.i.rowSeparatorHeight as number);
	}
	@Input()
	set rowSeparatorHeight(v: number) {
		this.i.rowSeparatorHeight = +v;
	}
	/**
	 * Configures whether or not place holders are used for cells who do not have their data yet.
	*/
	get isPlaceholderRenderingEnabled() : boolean {
		return (this.i.isPlaceholderRenderingEnabled as boolean);
	}
	@Input()
	set isPlaceholderRenderingEnabled(v: boolean) {
		this.i.isPlaceholderRenderingEnabled = ensureBool(v);
	}
	/**
	 * Sets or gets the Column Adding Animation mode to use.
	*/
	get columnAddingAnimationMode() : ColumnShowingAnimationMode {
		return this.i.columnAddingAnimationMode;
	}
	@Input()
	set columnAddingAnimationMode(v: ColumnShowingAnimationMode) {
		this.i.columnAddingAnimationMode = ensureEnum<ColumnShowingAnimationMode>(ColumnShowingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the Column Property Updating Animation mode to use.
	*/
	get columnPropertyUpdatingAnimationMode() : ColumnPropertyUpdatingAnimationMode {
		return this.i.columnPropertyUpdatingAnimationMode;
	}
	@Input()
	set columnPropertyUpdatingAnimationMode(v: ColumnPropertyUpdatingAnimationMode) {
		this.i.columnPropertyUpdatingAnimationMode = ensureEnum<ColumnPropertyUpdatingAnimationMode>(ColumnPropertyUpdatingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the cell data loaded animation mode to use.
	*/
	get cellDataLoadedAnimationMode() : CellDataLoadedAnimationMode {
		return this.i.cellDataLoadedAnimationMode;
	}
	@Input()
	set cellDataLoadedAnimationMode(v: CellDataLoadedAnimationMode) {
		this.i.cellDataLoadedAnimationMode = ensureEnum<CellDataLoadedAnimationMode>(CellDataLoadedAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the row selection animation mode to use.
	*/
	get rowSelectionAnimationMode() : RowSelectionAnimationMode {
		return this.i.rowSelectionAnimationMode;
	}
	@Input()
	set rowSelectionAnimationMode(v: RowSelectionAnimationMode) {
		this.i.rowSelectionAnimationMode = ensureEnum<RowSelectionAnimationMode>(RowSelectionAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the cell selection animation mode to use.
	*/
	get cellSelectionAnimationMode() : CellSelectionAnimationMode {
		return this.i.cellSelectionAnimationMode;
	}
	@Input()
	set cellSelectionAnimationMode(v: CellSelectionAnimationMode) {
		this.i.cellSelectionAnimationMode = ensureEnum<CellSelectionAnimationMode>(CellSelectionAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the default animation settings for the grid.
	*/
	get animationSettings() : IgxGridAnimationSettings {
	                                        if (this.i.animationSettings == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.animationSettings as any).externalObject) {
	                                            let e = new IgxGridAnimationSettings();
	                                            (e as any)._implementation = this.i.animationSettings;
	                                            (this.i.animationSettings as any).externalObject = e;
	                                        }
		return (this.i.animationSettings as any).externalObject;
	}
	@Input()
	set animationSettings(v: IgxGridAnimationSettings) {
		v == null ? this.i.animationSettings = null : this.i.animationSettings = v.i;
	}
	/**
	 * Sets or gets the column resizing animation mode to use. Only applies when resizing in Deferred mode.
	*/
	get columnResizingAnimationMode() : ColumnResizingAnimationMode {
		return this.i.columnResizingAnimationMode;
	}
	@Input()
	set columnResizingAnimationMode(v: ColumnResizingAnimationMode) {
		this.i.columnResizingAnimationMode = ensureEnum<ColumnResizingAnimationMode>(ColumnResizingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the column showing animation mode to use.
	*/
	get columnShowingAnimationMode() : ColumnShowingAnimationMode {
		return this.i.columnShowingAnimationMode;
	}
	@Input()
	set columnShowingAnimationMode(v: ColumnShowingAnimationMode) {
		this.i.columnShowingAnimationMode = ensureEnum<ColumnShowingAnimationMode>(ColumnShowingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the column moving animation mode to use.
	*/
	get columnMovingAnimationMode() : ColumnMovingAnimationMode {
		return this.i.columnMovingAnimationMode;
	}
	@Input()
	set columnMovingAnimationMode(v: ColumnMovingAnimationMode) {
		this.i.columnMovingAnimationMode = ensureEnum<ColumnMovingAnimationMode>(ColumnMovingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the column hiding animation mode to use.
	*/
	get columnHidingAnimationMode() : ColumnHidingAnimationMode {
		return this.i.columnHidingAnimationMode;
	}
	@Input()
	set columnHidingAnimationMode(v: ColumnHidingAnimationMode) {
		this.i.columnHidingAnimationMode = ensureEnum<ColumnHidingAnimationMode>(ColumnHidingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the column exchanging animation mode to use.
	*/
	get columnExchangingAnimationMode() : ColumnExchangingAnimationMode {
		return this.i.columnExchangingAnimationMode;
	}
	@Input()
	set columnExchangingAnimationMode(v: ColumnExchangingAnimationMode) {
		this.i.columnExchangingAnimationMode = ensureEnum<ColumnExchangingAnimationMode>(ColumnExchangingAnimationMode_$type, v);
	}
	/**
	 * Sets or gets the grid selection mode.
	*/
	get selectionMode() : GridSelectionMode {
		return this.i.selectionMode;
	}
	@Input()
	set selectionMode(v: GridSelectionMode) {
		this.i.selectionMode = ensureEnum<GridSelectionMode>(GridSelectionMode_$type, v);
	}
	/**
	 * Sets or gets the grid selection mode.
	*/
	get activationMode() : GridActivationMode {
		return this.i.activationMode;
	}
	@Input()
	set activationMode(v: GridActivationMode) {
		this.i.activationMode = ensureEnum<GridActivationMode>(GridActivationMode_$type, v);
	}
	/**
	 * Sets or gets how selection behaves in the grid.
	*/
	get selectionBehavior() : GridSelectionBehavior {
		return this.i.selectionBehavior;
	}
	@Input()
	set selectionBehavior(v: GridSelectionBehavior) {
		this.i.selectionBehavior = ensureEnum<GridSelectionBehavior>(GridSelectionBehavior_$type, v);
	}
	private _selectedItems: IgxGridSelectedItemsCollection = null;
	                                
	/**
	 * Gets which items are currently selected in the grid. Collection can be updated to programatically select items.
	*/
	get selectedItems() : IgxGridSelectedItemsCollection {
	                                        if (this._selectedItems === null) {
	                                            let coll = new IgxGridSelectedItemsCollection();
	                                            let innerColl = this.i.selectedItems;
			if (!innerColl) {
	                                            	innerColl = new GridSelectedItemsCollection_internal();
			}
	                                            this._selectedItems = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._selectedItems;
	}
	@Input()
	set selectedItems(v: IgxGridSelectedItemsCollection) {
	                                        if (this._selectedItems !== null) {
	                                            (this._selectedItems as any)._setSyncTarget(null);
	                                            this._selectedItems = null;
	                                        }
	                                        let coll = new IgxGridSelectedItemsCollection();
	                                        this._selectedItems = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<Object>((Base as any).$type);
	                                        let innerColl = this.i.selectedItems;
		if (!innerColl) {
	                                        	innerColl = new GridSelectedItemsCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._selectedItems as any)._setSyncTarget(syncColl);
	                                        
	}
	private _selectedKeys: IgxGridSelectedKeysCollection = null;
	                                
	/**
	 * Gets which primary key values are currently selected in the grid. Collection can be updated to programatically select items.
	*/
	get selectedKeys() : IgxGridSelectedKeysCollection {
	                                        if (this._selectedKeys === null) {
	                                            let coll = new IgxGridSelectedKeysCollection();
	                                            let innerColl = this.i.selectedKeys;
			if (!innerColl) {
	                                            	innerColl = new GridSelectedKeysCollection_internal();
			}
	                                            this._selectedKeys = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._selectedKeys;
	}
	@Input()
	set selectedKeys(v: IgxGridSelectedKeysCollection) {
	                                        if (this._selectedKeys !== null) {
	                                            (this._selectedKeys as any)._setSyncTarget(null);
	                                            this._selectedKeys = null;
	                                        }
	                                        let coll = new IgxGridSelectedKeysCollection();
	                                        this._selectedKeys = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<PrimaryKeyValue>((PrimaryKeyValue as any).$type);
	                                        let innerColl = this.i.selectedKeys;
		if (!innerColl) {
	                                        	innerColl = new GridSelectedKeysCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._selectedKeys as any)._setSyncTarget(syncColl);
	                                        
	}
	private _selectedCells: IgxGridSelectedCellsCollection = null;
	                                
	/**
	 * Gets which cells are currently selected in the grid. Collection can be updated to programatically select cells.
	*/
	get selectedCells() : IgxGridSelectedCellsCollection {
	                                        if (this._selectedCells === null) {
	                                            let coll = new IgxGridSelectedCellsCollection();
	                                            let innerColl = this.i.selectedCells;
			if (!innerColl) {
	                                            	innerColl = new GridSelectedCellsCollection_internal();
			}
	                                            this._selectedCells = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._selectedCells;
	}
	@Input()
	set selectedCells(v: IgxGridSelectedCellsCollection) {
	                                        if (this._selectedCells !== null) {
	                                            (this._selectedCells as any)._setSyncTarget(null);
	                                            this._selectedCells = null;
	                                        }
	                                        let coll = new IgxGridSelectedCellsCollection();
	                                        this._selectedCells = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<CellKey>((CellKey as any).$type);
	                                        let innerColl = this.i.selectedCells;
		if (!innerColl) {
	                                        	innerColl = new GridSelectedCellsCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._selectedCells as any)._setSyncTarget(syncColl);
	                                        
	}
	private _selectedCellRanges: IgxGridSelectedCellRangesCollection = null;
	                                
	/**
	 * Gets which cell ranges are currently selected in the grid. Collection can be updated to programatically select cells.
	*/
	get selectedCellRanges() : IgxGridSelectedCellRangesCollection {
	                                        if (this._selectedCellRanges === null) {
	                                            let coll = new IgxGridSelectedCellRangesCollection();
	                                            let innerColl = this.i.selectedCellRanges;
			if (!innerColl) {
	                                            	innerColl = new GridSelectedCellRangesCollection_internal();
			}
	                                            this._selectedCellRanges = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._selectedCellRanges;
	}
	@Input()
	set selectedCellRanges(v: IgxGridSelectedCellRangesCollection) {
	                                        if (this._selectedCellRanges !== null) {
	                                            (this._selectedCellRanges as any)._setSyncTarget(null);
	                                            this._selectedCellRanges = null;
	                                        }
	                                        let coll = new IgxGridSelectedCellRangesCollection();
	                                        this._selectedCellRanges = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<CellRange>((CellRange as any).$type);
	                                        let innerColl = this.i.selectedCellRanges;
		if (!innerColl) {
	                                        	innerColl = new GridSelectedCellRangesCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._selectedCellRanges as any)._setSyncTarget(syncColl);
	                                        
	}
	private _pinnedItems: IgxGridSelectedItemsCollection = null;
	                                
	/**
	 * Gets which items are currently pinned in the grid. Collection can be updated to programatically pin items.
	*/
	get pinnedItems() : IgxGridSelectedItemsCollection {
	                                        if (this._pinnedItems === null) {
	                                            let coll = new IgxGridSelectedItemsCollection();
	                                            let innerColl = this.i.pinnedItems;
			if (!innerColl) {
	                                            	innerColl = new GridSelectedItemsCollection_internal();
			}
	                                            this._pinnedItems = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._pinnedItems;
	}
	@Input()
	set pinnedItems(v: IgxGridSelectedItemsCollection) {
	                                        if (this._pinnedItems !== null) {
	                                            (this._pinnedItems as any)._setSyncTarget(null);
	                                            this._pinnedItems = null;
	                                        }
	                                        let coll = new IgxGridSelectedItemsCollection();
	                                        this._pinnedItems = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<Object>((Base as any).$type);
	                                        let innerColl = this.i.pinnedItems;
		if (!innerColl) {
	                                        	innerColl = new GridSelectedItemsCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._pinnedItems as any)._setSyncTarget(syncColl);
	                                        
	}
	private _pinnedKeys: IgxGridSelectedKeysCollection = null;
	                                
	/**
	 * Gets which primary keys are currently pinned in the grid. Collection can be updated to programatically pin items.
	*/
	get pinnedKeys() : IgxGridSelectedKeysCollection {
	                                        if (this._pinnedKeys === null) {
	                                            let coll = new IgxGridSelectedKeysCollection();
	                                            let innerColl = this.i.pinnedKeys;
			if (!innerColl) {
	                                            	innerColl = new GridSelectedKeysCollection_internal();
			}
	                                            this._pinnedKeys = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._pinnedKeys;
	}
	@Input()
	set pinnedKeys(v: IgxGridSelectedKeysCollection) {
	                                        if (this._pinnedKeys !== null) {
	                                            (this._pinnedKeys as any)._setSyncTarget(null);
	                                            this._pinnedKeys = null;
	                                        }
	                                        let coll = new IgxGridSelectedKeysCollection();
	                                        this._pinnedKeys = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<PrimaryKeyValue>((PrimaryKeyValue as any).$type);
	                                        let innerColl = this.i.pinnedKeys;
		if (!innerColl) {
	                                        	innerColl = new GridSelectedKeysCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._pinnedKeys as any)._setSyncTarget(syncColl);
	                                        
	}
	/**
	 * Gets or sets whether to show the filtering UI in the headers for columns where filtering is enabled.
	*/
	get isFilterUIEnabled() : boolean {
		return (this.i.isFilterUIEnabled as boolean);
	}
	@Input()
	set isFilterUIEnabled(v: boolean) {
		this.i.isFilterUIEnabled = ensureBool(v);
	}
	/**
	 * Gets or sets if group rows will stick to the top of the grid.
	*/
	get isGroupRowSticky() : boolean {
		return (this.i.isGroupRowSticky as boolean);
	}
	@Input()
	set isGroupRowSticky(v: boolean) {
		this.i.isGroupRowSticky = ensureBool(v);
	}
	/**
	 * Gets or sets if header separators are rendered.
	*/
	get isHeaderSeparatorVisible() : boolean {
		return (this.i.isHeaderSeparatorVisible as boolean);
	}
	@Input()
	set isHeaderSeparatorVisible(v: boolean) {
		this.i.isHeaderSeparatorVisible = ensureBool(v);
	}
	/**
	 * Gets or sets the default background color to use for content cells when a row is in a selected state
	*/
	get cellSelectedBackground() : string {
		return brushToString(this.i.cellSelectedBackground);
	}
	@Input()
	set cellSelectedBackground(v: string) {
		this.i.cellSelectedBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for section header cells when a row is in a selected state
	*/
	get sectionHeaderSelectedBackground() : string {
		return brushToString(this.i.sectionHeaderSelectedBackground);
	}
	@Input()
	set sectionHeaderSelectedBackground(v: string) {
		this.i.sectionHeaderSelectedBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for summary cells at the root level.
	*/
	get summaryRootBackground() : string {
		return brushToString(this.i.summaryRootBackground);
	}
	@Input()
	set summaryRootBackground(v: string) {
		this.i.summaryRootBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for summary cells at the section level.
	*/
	get summarySectionBackground() : string {
		return brushToString(this.i.summarySectionBackground);
	}
	@Input()
	set summarySectionBackground(v: string) {
		this.i.summarySectionBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default opacity to use for pinned rows
	*/
	get pinnedRowOpacity() : number {
		return (this.i.pinnedRowOpacity as number);
	}
	@Input()
	set pinnedRowOpacity(v: number) {
		this.i.pinnedRowOpacity = +v;
	}
	/**
	 * Gets or sets the default color to use for sticky rows
	*/
	get stickyRowBackground() : string {
		return brushToString(this.i.stickyRowBackground);
	}
	@Input()
	set stickyRowBackground(v: string) {
		this.i.stickyRowBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default color to use for pinned rows
	*/
	get pinnedRowBackground() : string {
		return brushToString(this.i.pinnedRowBackground);
	}
	@Input()
	set pinnedRowBackground(v: string) {
		this.i.pinnedRowBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default color to use for the last sticky row
	*/
	get lastStickyRowBackground() : string {
		return brushToString(this.i.lastStickyRowBackground);
	}
	@Input()
	set lastStickyRowBackground(v: string) {
		this.i.lastStickyRowBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the position of the active cell.
	*/
	get activeCell() : IgxGridCellPosition {
	                                        if (this.i.activeCell == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.activeCell as any).externalObject) {
	                                            let e = new IgxGridCellPosition();
	                                            (e as any)._implementation = this.i.activeCell;
	                                            (this.i.activeCell as any).externalObject = e;
	                                        }
		return (this.i.activeCell as any).externalObject;
	}
	@Input()
	set activeCell(v: IgxGridCellPosition) {
		v == null ? this.i.activeCell = null : this.i.activeCell = v.i;
	}
	/**
	 * Gets or sets the default background color to use for content cells
	*/
	get cellBackground() : string {
		return brushToString(this.i.cellBackground);
	}
	@Input()
	set cellBackground(v: string) {
		this.i.cellBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for content cells
	*/
	get cellTextColor() : string {
		return brushToString(this.i.cellTextColor);
	}
	@Input()
	set cellTextColor(v: string) {
		this.i.cellTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for content cells
	*/
	get headerSortIndicatorColor() : string {
		return brushToString(this.i.headerSortIndicatorColor);
	}
	@Input()
	set headerSortIndicatorColor(v: string) {
		this.i.headerSortIndicatorColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the default render style for sort indicators in header cells.
	*/
	get headerSortIndicatorStyle() : SortIndicatorStyle {
		return this.i.headerSortIndicatorStyle;
	}
	@Input()
	set headerSortIndicatorStyle(v: SortIndicatorStyle) {
		this.i.headerSortIndicatorStyle = ensureEnum<SortIndicatorStyle>(SortIndicatorStyle_$type, v);
	}
	/**
	 * Gets or sets the font to use for content cells
	*/
	get cellTextStyle() : string {
	                                    if (this.i.cellTextStyle == null) {
	                                        return null;
	                                    }
		return this.i.cellTextStyle.fontString;
	}
	@Input()
	set cellTextStyle(v: string) {
		let fi = new FontInfo();
	                                        fi.fontString = v;
	                                        this.i.cellTextStyle = fi;
	}
	/**
	 * Gets or sets the default background color to use for section header cells
	*/
	get sectionHeaderBackground() : string {
		return brushToString(this.i.sectionHeaderBackground);
	}
	@Input()
	set sectionHeaderBackground(v: string) {
		this.i.sectionHeaderBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for section header cells
	*/
	get sectionHeaderTextColor() : string {
		return brushToString(this.i.sectionHeaderTextColor);
	}
	@Input()
	set sectionHeaderTextColor(v: string) {
		this.i.sectionHeaderTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the font to use for section header cells
	*/
	get sectionHeaderTextStyle() : string {
	                                    if (this.i.sectionHeaderTextStyle == null) {
	                                        return null;
	                                    }
		return this.i.sectionHeaderTextStyle.fontString;
	}
	@Input()
	set sectionHeaderTextStyle(v: string) {
		let fi = new FontInfo();
	                                        fi.fontString = v;
	                                        this.i.sectionHeaderTextStyle = fi;
	}
	/**
	 * Gets or sets the default text color to use for summary cells at the root level.
	*/
	get summaryRootTextColor() : string {
		return brushToString(this.i.summaryRootTextColor);
	}
	@Input()
	set summaryRootTextColor(v: string) {
		this.i.summaryRootTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for summary cells at the section level.
	*/
	get summarySectionTextColor() : string {
		return brushToString(this.i.summarySectionTextColor);
	}
	@Input()
	set summarySectionTextColor(v: string) {
		this.i.summarySectionTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for summary names in summary cells at the root level.
	*/
	get summaryRootNameTextColor() : string {
		return brushToString(this.i.summaryRootNameTextColor);
	}
	@Input()
	set summaryRootNameTextColor(v: string) {
		this.i.summaryRootNameTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for summary names in summary cells at the section level.
	*/
	get summarySectionNameTextColor() : string {
		return brushToString(this.i.summarySectionNameTextColor);
	}
	@Input()
	set summarySectionNameTextColor(v: string) {
		this.i.summarySectionNameTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for summary cells at the root level.
	*/
	get summaryRootSelectedBackground() : string {
		return brushToString(this.i.summaryRootSelectedBackground);
	}
	@Input()
	set summaryRootSelectedBackground(v: string) {
		this.i.summaryRootSelectedBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for summary cells at the section level.
	*/
	get summarySectionSelectedBackground() : string {
		return brushToString(this.i.summarySectionSelectedBackground);
	}
	@Input()
	set summarySectionSelectedBackground(v: string) {
		this.i.summarySectionSelectedBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the font to use for summary cells
	*/
	get summaryTextStyle() : string {
	                                    if (this.i.summaryTextStyle == null) {
	                                        return null;
	                                    }
		return this.i.summaryTextStyle.fontString;
	}
	@Input()
	set summaryTextStyle(v: string) {
		let fi = new FontInfo();
	                                        fi.fontString = v;
	                                        this.i.summaryTextStyle = fi;
	}
	/**
	 * Gets or sets the font to use for header cells
	*/
	get summarySectionTextStyle() : string {
	                                    if (this.i.summarySectionTextStyle == null) {
	                                        return null;
	                                    }
		return this.i.summarySectionTextStyle.fontString;
	}
	@Input()
	set summarySectionTextStyle(v: string) {
		let fi = new FontInfo();
	                                        fi.fontString = v;
	                                        this.i.summarySectionTextStyle = fi;
	}
	/**
	 * Gets or sets the width of the pinned area separators.
	*/
	get pinnedAreaSeparatorWidth() : number {
		return (this.i.pinnedAreaSeparatorWidth as number);
	}
	@Input()
	set pinnedAreaSeparatorWidth(v: number) {
		this.i.pinnedAreaSeparatorWidth = +v;
	}
	/**
	 * Gets or sets the width of the header separators.
	*/
	get headerSeparatorWidth() : number {
		return (this.i.headerSeparatorWidth as number);
	}
	@Input()
	set headerSeparatorWidth(v: number) {
		this.i.headerSeparatorWidth = +v;
	}
	/**
	 * Gets or sets the default background color to use for header separators.
	*/
	get headerSeparatorBackground() : string {
		return brushToString(this.i.headerSeparatorBackground);
	}
	@Input()
	set headerSeparatorBackground(v: string) {
		this.i.headerSeparatorBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for header cells
	*/
	get headerBackground() : string {
		return brushToString(this.i.headerBackground);
	}
	@Input()
	set headerBackground(v: string) {
		this.i.headerBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default text color to use for header cells
	*/
	get headerTextColor() : string {
		return brushToString(this.i.headerTextColor);
	}
	@Input()
	set headerTextColor(v: string) {
		this.i.headerTextColor = stringToBrush(v);
	}
	/**
	 * Gets or sets the font to use for header cells
	*/
	get headerTextStyle() : string {
	                                    if (this.i.headerTextStyle == null) {
	                                        return null;
	                                    }
		return this.i.headerTextStyle.fontString;
	}
	@Input()
	set headerTextStyle(v: string) {
		let fi = new FontInfo();
	                                        fi.fontString = v;
	                                        this.i.headerTextStyle = fi;
	}
	/**
	 * Gets or sets the default background color to use for row separators
	*/
	get rowSeparatorBackground() : string {
		return brushToString(this.i.rowSeparatorBackground);
	}
	@Input()
	set rowSeparatorBackground(v: string) {
		this.i.rowSeparatorBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default sticky row background color to use for row separators
	*/
	get rowSeparatorStickyRowBackground() : string {
		return brushToString(this.i.rowSeparatorStickyRowBackground);
	}
	@Input()
	set rowSeparatorStickyRowBackground(v: string) {
		this.i.rowSeparatorStickyRowBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default last sticky row background color to use for row separators
	*/
	get rowSeparatorLastStickyRowBackground() : string {
		return brushToString(this.i.rowSeparatorLastStickyRowBackground);
	}
	@Input()
	set rowSeparatorLastStickyRowBackground(v: string) {
		this.i.rowSeparatorLastStickyRowBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the pinned row background color to use for row separators
	*/
	get rowSeparatorPinnedRowBackground() : string {
		return brushToString(this.i.rowSeparatorPinnedRowBackground);
	}
	@Input()
	set rowSeparatorPinnedRowBackground(v: string) {
		this.i.rowSeparatorPinnedRowBackground = stringToBrush(v);
	}
	/**
	 * Sets or gets the width to use for the column resizing separator.
	*/
	get columnResizingSeparatorWidth() : number {
		return (this.i.columnResizingSeparatorWidth as number);
	}
	@Input()
	set columnResizingSeparatorWidth(v: number) {
		this.i.columnResizingSeparatorWidth = +v;
	}
	/**
	 * Sets or gets the width to use for the column resizing separator.
	*/
	get columnMovingSeparatorWidth() : number {
		return (this.i.columnMovingSeparatorWidth as number);
	}
	@Input()
	set columnMovingSeparatorWidth(v: number) {
		this.i.columnMovingSeparatorWidth = +v;
	}
	/**
	 * Gets or sets the default background color to use for column resizing separator.
	*/
	get columnResizingSeparatorBackground() : string {
		return brushToString(this.i.columnResizingSeparatorBackground);
	}
	@Input()
	set columnResizingSeparatorBackground(v: string) {
		this.i.columnResizingSeparatorBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets the default background color to use for column moving separator.
	*/
	get columnMovingSeparatorBackground() : string {
		return brushToString(this.i.columnMovingSeparatorBackground);
	}
	@Input()
	set columnMovingSeparatorBackground(v: string) {
		this.i.columnMovingSeparatorBackground = stringToBrush(v);
	}
	/**
	 * Gets or sets if the section header content should be shifted into the normal column scrollable area when there are pinned columns
	*/
	get shiftSectionContent() : boolean {
		return (this.i.shiftSectionContent as boolean);
	}
	@Input()
	set shiftSectionContent(v: boolean) {
		this.i.shiftSectionContent = ensureBool(v);
	}
	private _responsiveStates: IgxResponsiveStatesCollection = null;
	                                
	/**
	 * A set of states that can be applied to the columns of the grid based on available space.
	*/
	get responsiveStates() : IgxResponsiveStatesCollection {
	                                        if (this._responsiveStates === null) {
	                                            let coll = new IgxResponsiveStatesCollection();
	                                            let innerColl = this.i.responsiveStates;
			if (!innerColl) {
	                                            	innerColl = new ResponsiveStatesCollection_internal();
			}
	                                            this._responsiveStates = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._responsiveStates;
	}
	@Input()
	set responsiveStates(v: IgxResponsiveStatesCollection) {
	                                        if (this._responsiveStates !== null) {
	                                            (this._responsiveStates as any)._setSyncTarget(null);
	                                            this._responsiveStates = null;
	                                        }
	                                        let coll = new IgxResponsiveStatesCollection();
	                                        this._responsiveStates = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<ResponsiveState>((ResponsiveState as any).$type);
	                                        let innerColl = this.i.responsiveStates;
		if (!innerColl) {
	                                        	innerColl = new ResponsiveStatesCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._responsiveStates as any)._setSyncTarget(syncColl);
	                                        
	}
	/**
	 * Gets the region of the grid that is visible.
	*/
	get actualVisibleRegion() : IgRect {
		return fromRect(this.i.actualVisibleRegion);
	}
	/**
	 * Gets the current sort that is applied to the grid. Collection can be updated to modify the sort for the grid. Once sort descriptions are in this collection, the grid will no longer listen for changes on their properties.
	*/
	get sortDescriptions() : IgxColumnSortDescriptionCollection {
	                                        if (this.i.sortDescriptions == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.sortDescriptions as any).externalObject) {
	                                            let e = new IgxColumnSortDescriptionCollection();
	                                            (e as any)._implementation = this.i.sortDescriptions;
	                                            (this.i.sortDescriptions as any).externalObject = e;
	                                        }
		return (this.i.sortDescriptions as any).externalObject;
	}
	/**
	 * Gets the current grouping that is applied to the grid. Collection can be updated to modify the grouping for the grid. Once grouping descriptions are in this collection, the grid will no longer listen for changes on their properties.
	*/
	get groupDescriptions() : IgxColumnGroupDescriptionCollection {
	                                        if (this.i.groupDescriptions == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.groupDescriptions as any).externalObject) {
	                                            let e = new IgxColumnGroupDescriptionCollection();
	                                            (e as any)._implementation = this.i.groupDescriptions;
	                                            (this.i.groupDescriptions as any).externalObject = e;
	                                        }
		return (this.i.groupDescriptions as any).externalObject;
	}
	/**
	 * Gets the current filter that is applied to the grid. Collection can be updated to modify the filter for the grid. Once filter expresisons are in this collection, the grid will no longer listen for changes on their properties.
	*/
	get filterExpressions() : IgxFilterExpressionCollection {
	                                        if (this.i.filterExpressions == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.filterExpressions as any).externalObject) {
	                                            let e = new IgxFilterExpressionCollection();
	                                            (e as any)._implementation = this.i.filterExpressions;
	                                            (this.i.filterExpressions as any).externalObject = e;
	                                        }
		return (this.i.filterExpressions as any).externalObject;
	}
	/**
	 * Gets the current summaries that are applied to the grid.
	*/
	get summaryDescriptions() : IgxColumnSummaryDescriptionCollection {
	                                        if (this.i.summaryDescriptions == null) {
	                                            return null;
	                                        }
	                                        
	                                        if (!(this.i.summaryDescriptions as any).externalObject) {
	                                            let e = new IgxColumnSummaryDescriptionCollection();
	                                            (e as any)._implementation = this.i.summaryDescriptions;
	                                            (this.i.summaryDescriptions as any).externalObject = e;
	                                        }
		return (this.i.summaryDescriptions as any).externalObject;
	}
	/**
	 * Gets or sets the scope which summaries are calculated for.
	*/
	get summaryScope() : DataSourceSummaryScope {
		return this.i.summaryScope;
	}
	@Input()
	set summaryScope(v: DataSourceSummaryScope) {
		this.i.summaryScope = ensureEnum<DataSourceSummaryScope>(DataSourceSummaryScope_$type, v);
	}
	/**
	 * Gets or sets whether group headers are collapsable.
	*/
	get isGroupCollapsable() : boolean {
		return (this.i.isGroupCollapsable as boolean);
	}
	@Input()
	set isGroupCollapsable(v: boolean) {
		this.i.isGroupCollapsable = ensureBool(v);
	}
	/**
	 * Gets or sets how group headers are displayed when there are multiple groups defined in the grid.
	*/
	get groupHeaderDisplayMode() : DataSourceSectionHeaderDisplayMode {
		return this.i.groupHeaderDisplayMode;
	}
	@Input()
	set groupHeaderDisplayMode(v: DataSourceSectionHeaderDisplayMode) {
		this.i.groupHeaderDisplayMode = ensureEnum<DataSourceSectionHeaderDisplayMode>(DataSourceSectionHeaderDisplayMode_$type, v);
	}
	/**
	 * Gets or sets whether groups are expanded or collapsed by default.
	*/
	get isGroupExpandedDefault() : boolean {
		return (this.i.isGroupExpandedDefault as boolean);
	}
	@Input()
	set isGroupExpandedDefault(v: boolean) {
		this.i.isGroupExpandedDefault = ensureBool(v);
	}
	/**
	 * Gets or sets the display mode summaries will use inside groups.
	*/
	get groupSummaryDisplayMode() : GroupSummaryDisplayMode {
		return this.i.groupSummaryDisplayMode;
	}
	@Input()
	set groupSummaryDisplayMode(v: GroupSummaryDisplayMode) {
		this.i.groupSummaryDisplayMode = ensureEnum<GroupSummaryDisplayMode>(GroupSummaryDisplayMode_$type, v);
	}
	/**
	 * Sets or gets the user provided primary key to assume for the data. Certain functionality of the grid requires a way to uniquely identify items in order to work correctly.
	 * If a primary key cannot be inferred from the data source, you may need to provide one here.
	*/
	get primaryKey() : string[] {
		return this.i.primaryKey as string[];
	}
	@Input()
	set primaryKey(v: string[]) {
		this.i.primaryKey = v;
	}
	/**
	 * Gets either the inferred primary key from the data source, or the user provided primary key, if present. Represents the actual primary key that the grid will use in operations that require it.
	*/
	get actualPrimaryKey() : string[] {
		return this.i.actualPrimaryKey as string[];
	}
	@Input()
	set actualPrimaryKey(v: string[]) {
		this.i.actualPrimaryKey = v;
	}
	private _actualColumns: IgxGridColumnCollection = null;
	                                
	get actualColumns() : IgxGridColumnCollection {
	                                        if (this._actualColumns === null) {
	                                            let coll = new IgxGridColumnCollection();
	                                            let innerColl = this.i.actualColumns;
			if (!innerColl) {
	                                            	innerColl = new GridColumnCollection_internal();
			}
	                                            this._actualColumns = (coll as any)._fromInner(innerColl);
	                                            
	                                        }
		return this._actualColumns;
	}
	@Input()
	set actualColumns(v: IgxGridColumnCollection) {
	                                        if (this._actualColumns !== null) {
	                                            (this._actualColumns as any)._setSyncTarget(null);
	                                            this._actualColumns = null;
	                                        }
	                                        let coll = new IgxGridColumnCollection();
	                                        this._actualColumns = (coll as any)._fromOuter(v);
	                                        let syncColl = new SyncableObservableCollection$1<Column>((Column as any).$type);
	                                        let innerColl = this.i.actualColumns;
		if (!innerColl) {
	                                        	innerColl = new GridColumnCollection_internal();
		}
	                                        (syncColl as any)._inner = innerColl;
	                                        syncColl.clear();
	                                        (this._actualColumns as any)._setSyncTarget(syncColl);
	                                        
	}
	/**
	 * Sets or gets whether the grid will react to sort changes.
	*/
	get reactsToSortChanges() : boolean {
		return (this.i.reactsToSortChanges as boolean);
	}
	@Input()
	set reactsToSortChanges(v: boolean) {
		this.i.reactsToSortChanges = ensureBool(v);
	}
	/**
	 * Sets or gets whether the grid will react to group changes.
	*/
	get reactsToGroupChanges() : boolean {
		return (this.i.reactsToGroupChanges as boolean);
	}
	@Input()
	set reactsToGroupChanges(v: boolean) {
		this.i.reactsToGroupChanges = ensureBool(v);
	}
	/**
	 * Sets or gets whether the grid will react to filter changes.
	*/
	get reactsToFilterChanges() : boolean {
		return (this.i.reactsToFilterChanges as boolean);
	}
	@Input()
	set reactsToFilterChanges(v: boolean) {
		this.i.reactsToFilterChanges = ensureBool(v);
	}

    	
	protected __p: string = null;
	protected _hasUserValues: Set<string> = new Set<string>();
	protected get hasUserValues(): Set<string> {
	    return this._hasUserValues;
	}
	protected __m(propertyName: string) {
	    if (!this._inStyling) {
	        this._hasUserValues.add(propertyName);
	    }
	}
	
	protected _stylingContainer: any = null;
	protected _stylingParent: any = null;
	protected _inStyling: boolean = false;
	protected _styling(container: any, component: any, parent?: any) {
	        if (this._inStyling) {
	            return;
	        }
	        this._inStyling = true;
	        this._stylingContainer = container;
	        this._stylingParent = component;
		
	        let genericPrefix = "";
	        let typeName = (this.i as any).$type.name;
	        if (typeName.indexOf("Xam") === 0) {
	            typeName = typeName.substring(3);
	        }
	        genericPrefix = toSpinal("LiveGridComponent");
		
		let additionalPrefixes = [];
		
		let prefix = toSpinal(typeName);
		additionalPrefixes.push(prefix + "-");
	
	        let b = (this.i as any).$type.baseType;
	        while (b && b.name != "Object" && 
	            b.name != "Base" && 
	            b.name != "Control" && 
	            b.Name != "DependencyObject" &&
	            b.Name != "FrameworkElement") {
	            typeName = b.name;
	            if (typeName.indexOf("Xam") === 0) {
	                typeName = typeName.substring(3);
	            }
	            let basePrefix = toSpinal(typeName);
	            additionalPrefixes.push(basePrefix + "-");
	            b = b.baseType;
	        }
		
		if (parent) {
			let parentTypeName = (parent.i as any).$type.name;
	            if (parentTypeName.indexOf("Xam") === 0) {
	                parentTypeName = parentTypeName.substring(3);
	            }
	            let parentPrefix = toSpinal(parentTypeName);
	
			additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
			additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
		}
	
		initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
	
	        if (this.sectionHeader && (this.sectionHeader as any)._styling) {
	    (this.sectionHeader as any)._styling(container, component, this);
	}
	if (this.summaryRowRoot && (this.summaryRowRoot as any)._styling) {
	    (this.summaryRowRoot as any)._styling(container, component, this);
	}
	if (this.summaryRowSection && (this.summaryRowSection as any)._styling) {
	    (this.summaryRowSection as any)._styling(container, component, this);
	}
	if (this.rowSeparator && (this.rowSeparator as any)._styling) {
	    (this.rowSeparator as any)._styling(container, component, this);
	}
	if (this.headerSeparator && (this.headerSeparator as any)._styling) {
	    (this.headerSeparator as any)._styling(container, component, this);
	}
	if (this.columnResizingSeparator && (this.columnResizingSeparator as any)._styling) {
	    (this.columnResizingSeparator as any)._styling(container, component, this);
	}
	if (this.columnMovingSeparator && (this.columnMovingSeparator as any)._styling) {
	    (this.columnMovingSeparator as any)._styling(container, component, this);
	}
	if (this.pinnedAreaSeparator && (this.pinnedAreaSeparator as any)._styling) {
	    (this.pinnedAreaSeparator as any)._styling(container, component, this);
	}
	
	
	        if ((this as any)._otherStyling) {
	            (this as any)._otherStyling(container, component, parent);
	        }
	        this._inStyling = false;
	}

		public getHitCell(x: number, y: number) : IgxCellInfo {
		let iv = this.i.getHitCell(x, y);
		return (iv == null ? null : (iv as any).externalObject);
	}
	/**
	 * Forces a refresh of the grid content.
	
	*/
	public refresh() {
		this.i.refresh();
	}
	/**
	 * Makes sure pending work has completed if the grid need to be synchronously examined.
	
	*/
	public flush() {
		this.i.flush();
	}
	public exchangeColumn(newColumn: IgxColumnComponent, oldColumn: IgxColumnComponent) {
		this.i.exchangeColumn((newColumn == null ? null : newColumn.i), (oldColumn == null ? null : oldColumn.i));
	}
	public pinColumn(column: IgxColumnComponent, position: PinnedPositions) {
		this.i.pinColumn((column == null ? null : column.i), (position == null ? null : position));
	}
	public moveColumn(oldIndex: number, newIndex: number) {
		this.i.moveColumn(oldIndex, newIndex);
	}
	/**
	 * Moves a column to the left, if possible.
	
	* @param columnIndex  * The index of the column to move.
	*/
	public moveColumnLeft(columnIndex: number) {
		this.i.moveColumnLeft(columnIndex);
	}
	/**
	 * Moves a column to the right, if possible.
	
	* @param columnIndex  * The index of the column to move.
	*/
	public moveColumnRight(columnIndex: number) {
		this.i.moveColumnRight(columnIndex);
	}
	/**
	 * Returns true if a column can be moved to the left of it's current position; otherwise false.
	
	* @param columnIndex  * The index of the column.
	*/
	public canMoveColumnLeft(columnIndex: number) : boolean {
		let iv = this.i.canMoveColumnLeft(columnIndex);
		return (iv);
	}
	/**
	 * Returns true if a column can be moved to the right of it's current position; otherwise false.
	
	* @param columnIndex  * The index of the column.
	*/
	public canMoveColumnRight(columnIndex: number) : boolean {
		let iv = this.i.canMoveColumnRight(columnIndex);
		return (iv);
	}
	/**
	 * Exports visual information about the current state of the grid.
	
	*/
	public exportVisualModel() : any {
		let iv = this.i.exportVisualModel();
		return (iv);
	}
	/**
	 * Returns a serialized copy of the exported visual model
	
	*/
	public exportSerializedVisualModel() : string {
		let iv = this.i.exportSerializedVisualModel();
		return (iv);
	}
	/**
	 * Scrolls the grid to given row, by index
	
	* @param rowNumber  * The row index to scroll to.
	*/
	public scrollToRowByIndex(rowNumber: number) {
		this.i.scrollToRowByIndex(rowNumber);
	}
	/**
	 * Scrolls the grid so that a row is the last visible, by index.
	
	* @param rowNumber  * The row index to scroll to.
	*/
	public scrollToLastRowByIndex(rowNumber: number) {
		this.i.scrollToLastRowByIndex(rowNumber);
	}
	/**
	 * Scrolls to an item, if found.
	
	* @param item  * The item to scroll to.
	*/
	public scrollToItem(item: any) : boolean {
		let iv = this.i.scrollToItem(item);
		return (iv);
	}
	public scrollToPrimaryKey(key: any[]) : boolean {
		let iv = this.i.scrollToPrimaryKey(key);
		return (iv);
	}
	/**
	 * Scrolls the grid to given column, by index
	
	* @param columnNumber  * The column number to scroll to.
	*/
	public scrollToColumnByIndex(columnNumber: number) {
		this.i.scrollToColumnByIndex(columnNumber);
	}
	/**
	 * Gets the last visible index in the grid.
	
	*/
	public getLastVisibleIndex() : number {
		let iv = this.i.getLastVisibleIndex();
		return (iv);
	}
	/**
	 * Gets the first visible index in the grid.
	
	*/
	public getFirstVisibleIndex() : number {
		let iv = this.i.getFirstVisibleIndex();
		return (iv);
	}
	/**
	 * Invalidates the bound data for the rows currently visible.
	
	*/
	public invalidateVisibleRows() {
		this.i.invalidateVisibleRows();
	}
	/**
	 * Manually set the active responsive state of the grid.
	
	* @param name 
	*/
	public setActiveResponsiveState1(name: string) {
		this.i.setActiveResponsiveState1(name);
	}
	public notifySetItem(index: number, oldItem: any, newItem: any) {
		this.i.notifySetItem(index, oldItem, newItem);
	}
	/**
	 * Manually notifies the grid's data source that the data it has bound to has been cleared and needs to be re-examined.
	 * This should not be called if the data that the grid is bound to is already observable.
	
	*/
	public notifyClearItems() {
		this.i.notifyClearItems();
	}
	public notifyInsertItem(index: number, newItem: any) {
		this.i.notifyInsertItem(index, newItem);
	}
	public notifyRemoveItem(index: number, oldItem: any) {
		this.i.notifyRemoveItem(index, oldItem);
	}
	/**
	 * Returns the data index of an item within the bound data source.
	
	* @param item  * The item from which to get the index.
	*/
	public dataIndexOfItem(item: any) : number {
		let iv = this.i.dataIndexOfItem(item);
		return (iv);
	}
	public dataIndexOfPrimaryKey(key: any[]) : number {
		let iv = this.i.dataIndexOfPrimaryKey(key);
		return (iv);
	}
	/**
	 * Resolves the value of a specific cell.
	
	* @param cellKey  * The cell to resolve.
	*/
	public resolveCellValue(cellKey: IgxCellKey) : any {
		let iv = this.i.resolveCellValue((cellKey == null ? null : cellKey.i));
		return (iv);
	}
	public resolveCellValueFromPosition(row: number, column: number) : any {
		let iv = this.i.resolveCellValueFromPosition(row, column);
		return (iv);
	}
	/**
	 * Gets the column that appears at the index specified. This is not the columns actual index in the
	 * column's collection but the index for how it appears visually in the grid.
	
	* @param index  * The rendered index of the column.
	*/
	public getColumnAtRenderedIndex(index: number) : IgxColumnComponent {
		let iv = this.i.getColumnAtRenderedIndex(index);
		return (iv == null ? null : (iv as any).externalObject);
	}
	/**
	 * Gets the summary results for root level.
	
	*/
	public getRootSummaryResults() : ISummaryResult[] {
		let iv = this.i.getRootSummaryResults();
		return (iv);
	}
	/**
	 * Gets the summary results for a specific section.
	
	*/
	public getSectionSummaryResults(sectionIndex: number) : ISummaryResult[][] {
		let iv = this.i.getSectionSummaryResults(sectionIndex);
		return (iv);
	}

    	private _filterExpressionsChanging: EventEmitter<{ sender: any, args: IgxGridFilterExpressionsEventArgs}> = null;
	@Output()
	get filterExpressionsChanging(): EventEmitter<{ sender: any, args: IgxGridFilterExpressionsEventArgs}> {
		if (this._filterExpressionsChanging == null) {
			this._filterExpressionsChanging = new EventEmitter<{sender: any, args: IgxGridFilterExpressionsEventArgs}>();
			this.i.filterExpressionsChanging = delegateCombine(this.i.filterExpressionsChanging, (o, e) => {
				let outerArgs = new IgxGridFilterExpressionsEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeFilterExpressionsChanging) {
	                            (this as any).beforeFilterExpressionsChanging(this, outerArgs);
	                        }
					    this._filterExpressionsChanging.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._filterExpressionsChanging;
	}
	private _filterExpressionsChanged: EventEmitter<{ sender: any, args: IgxGridFilterExpressionsEventArgs}> = null;
	@Output()
	get filterExpressionsChanged(): EventEmitter<{ sender: any, args: IgxGridFilterExpressionsEventArgs}> {
		if (this._filterExpressionsChanged == null) {
			this._filterExpressionsChanged = new EventEmitter<{sender: any, args: IgxGridFilterExpressionsEventArgs}>();
			this.i.filterExpressionsChanged = delegateCombine(this.i.filterExpressionsChanged, (o, e) => {
				let outerArgs = new IgxGridFilterExpressionsEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeFilterExpressionsChanged) {
	                            (this as any).beforeFilterExpressionsChanged(this, outerArgs);
	                        }
					    this._filterExpressionsChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._filterExpressionsChanged;
	}
	private _cellPreviewPointerDown: EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> = null;
	/**
	 * Previews that a pointer is down on a cell.
	*/
	@Output()
	get cellPreviewPointerDown(): EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> {
		if (this._cellPreviewPointerDown == null) {
			this._cellPreviewPointerDown = new EventEmitter<{sender: any, args: IgxGridCellEventArgs}>();
			this.i.cellPreviewPointerDown = delegateCombine(this.i.cellPreviewPointerDown, (o, e) => {
				let outerArgs = new IgxGridCellEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeCellPreviewPointerDown) {
	                            (this as any).beforeCellPreviewPointerDown(this, outerArgs);
	                        }
					    this._cellPreviewPointerDown.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._cellPreviewPointerDown;
	}
	private _cellPreviewPointerUp: EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> = null;
	/**
	 * Previews that a pointer is up on a cell.
	*/
	@Output()
	get cellPreviewPointerUp(): EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> {
		if (this._cellPreviewPointerUp == null) {
			this._cellPreviewPointerUp = new EventEmitter<{sender: any, args: IgxGridCellEventArgs}>();
			this.i.cellPreviewPointerUp = delegateCombine(this.i.cellPreviewPointerUp, (o, e) => {
				let outerArgs = new IgxGridCellEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeCellPreviewPointerUp) {
	                            (this as any).beforeCellPreviewPointerUp(this, outerArgs);
	                        }
					    this._cellPreviewPointerUp.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._cellPreviewPointerUp;
	}
	private _cellPointerDown: EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> = null;
	/**
	 * Indicates a pointer is down on a cell.
	*/
	@Output()
	get cellPointerDown(): EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> {
		if (this._cellPointerDown == null) {
			this._cellPointerDown = new EventEmitter<{sender: any, args: IgxGridCellEventArgs}>();
			this.i.cellPointerDown = delegateCombine(this.i.cellPointerDown, (o, e) => {
				let outerArgs = new IgxGridCellEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeCellPointerDown) {
	                            (this as any).beforeCellPointerDown(this, outerArgs);
	                        }
					    this._cellPointerDown.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._cellPointerDown;
	}
	private _cellPointerUp: EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> = null;
	/**
	 * Indicates a pointer is up on a cell.
	*/
	@Output()
	get cellPointerUp(): EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> {
		if (this._cellPointerUp == null) {
			this._cellPointerUp = new EventEmitter<{sender: any, args: IgxGridCellEventArgs}>();
			this.i.cellPointerUp = delegateCombine(this.i.cellPointerUp, (o, e) => {
				let outerArgs = new IgxGridCellEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeCellPointerUp) {
	                            (this as any).beforeCellPointerUp(this, outerArgs);
	                        }
					    this._cellPointerUp.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._cellPointerUp;
	}
	private _cellClicked: EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> = null;
	/**
	 * Called when a cell is clicked.
	*/
	@Output()
	get cellClicked(): EventEmitter<{ sender: any, args: IgxGridCellEventArgs}> {
		if (this._cellClicked == null) {
			this._cellClicked = new EventEmitter<{sender: any, args: IgxGridCellEventArgs}>();
			this.i.cellClicked = delegateCombine(this.i.cellClicked, (o, e) => {
				let outerArgs = new IgxGridCellEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeCellClicked) {
	                            (this as any).beforeCellClicked(this, outerArgs);
	                        }
					    this._cellClicked.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._cellClicked;
	}
	private _sortDescriptionsChanged: EventEmitter<{ sender: any, args: IgxGridSortDescriptionsChangedEventArgs}> = null;
	/**
	 * Called when sorting has changed.
	*/
	@Output()
	get sortDescriptionsChanged(): EventEmitter<{ sender: any, args: IgxGridSortDescriptionsChangedEventArgs}> {
		if (this._sortDescriptionsChanged == null) {
			this._sortDescriptionsChanged = new EventEmitter<{sender: any, args: IgxGridSortDescriptionsChangedEventArgs}>();
			this.i.sortDescriptionsChanged = delegateCombine(this.i.sortDescriptionsChanged, (o, e) => {
				let outerArgs = new IgxGridSortDescriptionsChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeSortDescriptionsChanged) {
	                            (this as any).beforeSortDescriptionsChanged(this, outerArgs);
	                        }
					    this._sortDescriptionsChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._sortDescriptionsChanged;
	}
	private _groupDescriptionsChanged: EventEmitter<{ sender: any, args: IgxGridGroupDescriptionsChangedEventArgs}> = null;
	/**
	 * Called when grouping has changed.
	*/
	@Output()
	get groupDescriptionsChanged(): EventEmitter<{ sender: any, args: IgxGridGroupDescriptionsChangedEventArgs}> {
		if (this._groupDescriptionsChanged == null) {
			this._groupDescriptionsChanged = new EventEmitter<{sender: any, args: IgxGridGroupDescriptionsChangedEventArgs}>();
			this.i.groupDescriptionsChanged = delegateCombine(this.i.groupDescriptionsChanged, (o, e) => {
				let outerArgs = new IgxGridGroupDescriptionsChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeGroupDescriptionsChanged) {
	                            (this as any).beforeGroupDescriptionsChanged(this, outerArgs);
	                        }
					    this._groupDescriptionsChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._groupDescriptionsChanged;
	}
	private _columnHiddenChanged: EventEmitter<{ sender: any, args: IgxColumnHiddenChangedEventArgs}> = null;
	/**
	 * Called when a column is hidden or unhidden.
	*/
	@Output()
	get columnHiddenChanged(): EventEmitter<{ sender: any, args: IgxColumnHiddenChangedEventArgs}> {
		if (this._columnHiddenChanged == null) {
			this._columnHiddenChanged = new EventEmitter<{sender: any, args: IgxColumnHiddenChangedEventArgs}>();
			this.i.columnHiddenChanged = delegateCombine(this.i.columnHiddenChanged, (o, e) => {
				let outerArgs = new IgxColumnHiddenChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeColumnHiddenChanged) {
	                            (this as any).beforeColumnHiddenChanged(this, outerArgs);
	                        }
					    this._columnHiddenChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._columnHiddenChanged;
	}
	private _columnsAutoGenerated: EventEmitter<{ sender: any, args: IgxGridColumnsAutoGeneratedEventArgs}> = null;
	/**
	 * Called when the columns are autogenerated.
	*/
	@Output()
	get columnsAutoGenerated(): EventEmitter<{ sender: any, args: IgxGridColumnsAutoGeneratedEventArgs}> {
		if (this._columnsAutoGenerated == null) {
			this._columnsAutoGenerated = new EventEmitter<{sender: any, args: IgxGridColumnsAutoGeneratedEventArgs}>();
			this.i.columnsAutoGenerated = delegateCombine(this.i.columnsAutoGenerated, (o, e) => {
				let outerArgs = new IgxGridColumnsAutoGeneratedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeColumnsAutoGenerated) {
	                            (this as any).beforeColumnsAutoGenerated(this, outerArgs);
	                        }
					    this._columnsAutoGenerated.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._columnsAutoGenerated;
	}
	private _selectedItemsChanged: EventEmitter<{ sender: any, args: IgxGridSelectedItemsChangedEventArgs}> = null;
	/**
	 * Called when the selected items change.
	*/
	@Output()
	get selectedItemsChanged(): EventEmitter<{ sender: any, args: IgxGridSelectedItemsChangedEventArgs}> {
		if (this._selectedItemsChanged == null) {
			this._selectedItemsChanged = new EventEmitter<{sender: any, args: IgxGridSelectedItemsChangedEventArgs}>();
			this.i.selectedItemsChanged = delegateCombine(this.i.selectedItemsChanged, (o, e) => {
				let outerArgs = new IgxGridSelectedItemsChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeSelectedItemsChanged) {
	                            (this as any).beforeSelectedItemsChanged(this, outerArgs);
	                        }
					    this._selectedItemsChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._selectedItemsChanged;
	}
	private _selectedKeysChanged: EventEmitter<{ sender: any, args: IgxGridSelectedKeysChangedEventArgs}> = null;
	/**
	 * Called when the selected keys change.
	*/
	@Output()
	get selectedKeysChanged(): EventEmitter<{ sender: any, args: IgxGridSelectedKeysChangedEventArgs}> {
		if (this._selectedKeysChanged == null) {
			this._selectedKeysChanged = new EventEmitter<{sender: any, args: IgxGridSelectedKeysChangedEventArgs}>();
			this.i.selectedKeysChanged = delegateCombine(this.i.selectedKeysChanged, (o, e) => {
				let outerArgs = new IgxGridSelectedKeysChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeSelectedKeysChanged) {
	                            (this as any).beforeSelectedKeysChanged(this, outerArgs);
	                        }
					    this._selectedKeysChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._selectedKeysChanged;
	}
	private _selectedCellsChanged: EventEmitter<{ sender: any, args: IgxGridSelectedCellsChangedEventArgs}> = null;
	/**
	 * Called when the selected cells change.
	*/
	@Output()
	get selectedCellsChanged(): EventEmitter<{ sender: any, args: IgxGridSelectedCellsChangedEventArgs}> {
		if (this._selectedCellsChanged == null) {
			this._selectedCellsChanged = new EventEmitter<{sender: any, args: IgxGridSelectedCellsChangedEventArgs}>();
			this.i.selectedCellsChanged = delegateCombine(this.i.selectedCellsChanged, (o, e) => {
				let outerArgs = new IgxGridSelectedCellsChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeSelectedCellsChanged) {
	                            (this as any).beforeSelectedCellsChanged(this, outerArgs);
	                        }
					    this._selectedCellsChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._selectedCellsChanged;
	}
	private _activeCellChanged: EventEmitter<{ sender: any, args: IgxGridActiveCellChangedEventArgs}> = null;
	/**
	 * Called when the active cell changes.
	*/
	@Output()
	get activeCellChanged(): EventEmitter<{ sender: any, args: IgxGridActiveCellChangedEventArgs}> {
		if (this._activeCellChanged == null) {
			this._activeCellChanged = new EventEmitter<{sender: any, args: IgxGridActiveCellChangedEventArgs}>();
			this.i.activeCellChanged = delegateCombine(this.i.activeCellChanged, (o, e) => {
				let outerArgs = new IgxGridActiveCellChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeActiveCellChanged) {
	                            (this as any).beforeActiveCellChanged(this, outerArgs);
	                        }
					    this._activeCellChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._activeCellChanged;
	}
	private _selectedCellRangesChanged: EventEmitter<{ sender: any, args: IgxGridSelectedCellRangesChangedEventArgs}> = null;
	/**
	 * Called when the selected cell ranges changed.
	*/
	@Output()
	get selectedCellRangesChanged(): EventEmitter<{ sender: any, args: IgxGridSelectedCellRangesChangedEventArgs}> {
		if (this._selectedCellRangesChanged == null) {
			this._selectedCellRangesChanged = new EventEmitter<{sender: any, args: IgxGridSelectedCellRangesChangedEventArgs}>();
			this.i.selectedCellRangesChanged = delegateCombine(this.i.selectedCellRangesChanged, (o, e) => {
				let outerArgs = new IgxGridSelectedCellRangesChangedEventArgs();
					    (<any>outerArgs)._provideImplementation(e);
	                        if ((this as any).beforeSelectedCellRangesChanged) {
	                            (this as any).beforeSelectedCellRangesChanged(this, outerArgs);
	                        }
					    this._selectedCellRangesChanged.emit({
						    sender: this,
						    args: outerArgs
					    });
			});
		}
		return this._selectedCellRangesChanged;
	}

    	protected _zoneRunner: (act: () => void) => void = null;
	protected _runInZone(act: () => void): void {
	    if (this._zoneRunner != null) {
	        this._zoneRunner(act);
	    } else {
	        act();
	    }
	}
}