/* 
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE: 
https://www.infragistics.com/legal/license/igultimate-la 
https://www.infragistics.com/legal/license/igultimate-eula 
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/

import { Base, typeCast, typeGetValue, EnumUtil, enumGetBox, Type, markType, IComparable, IComparable_$type, ICollection$1, ICollection$1_$type, IList$1, IList$1_$type, String_$type, Number_$type, Boolean_$type, Date_$type, getInstanceType } from "./type";
import { IFilterExpression, IFilterExpression_$type } from "./IFilterExpression";
import { DataSourceSchemaPropertyType, DataSourceSchemaPropertyType_$type } from "./DataSourceSchemaPropertyType";
import { FilterExpressionOperatorType } from "./FilterExpressionOperatorType";
import { FilterExpressionFunctionType } from "./FilterExpressionFunctionType";
import { IDataSourceDataProvider } from "./IDataSourceDataProvider";
import { IDataSourceSchema } from "./IDataSourceSchema";
import { Convert } from "./Convert";
import { IOperationFilterExpression, IOperationFilterExpression_$type } from "./IOperationFilterExpression";
import { NotImplementedException } from "./NotImplementedException";
import { InvalidOperationException } from "./InvalidOperationException";
import { intDivide, isNaN_ } from "./number";
import { CompareUtil } from "./compareUtil";
import { stringCompareTo, stringConcat, stringEndsWith, stringReplace, stringStartsWith, stringContains } from "./string";
import { IFunctionFilterExpression, IFunctionFilterExpression_$type } from "./IFunctionFilterExpression";
import { FilterExpressionCollection } from "./FilterExpressionCollection";
import { dateGetMonth, dateGetDate, dateNow } from "./date";
import { IPropertyReferenceFilterExpression, IPropertyReferenceFilterExpression_$type } from "./IPropertyReferenceFilterExpression";
import { ILiteralFilterExpression, ILiteralFilterExpression_$type } from "./ILiteralFilterExpression";

/**
 * @hidden 
 */
export abstract class FilterExpression extends Base implements IFilterExpression {
	static $t: Type = markType(FilterExpression, 'FilterExpression', (<any>Base).$type, [IFilterExpression_$type]);
	private _hasBooleanReturn: boolean = false;
	abstract get precedence(): number;
	private _isAutoGenerated: boolean = false;
	markAutoGenerated(): void {
		this._isAutoGenerated = true;
	}
	get isAutoGenerated(): boolean {
		return this._isAutoGenerated;
	}
	static isFilterExpression(val: any): boolean {
		return typeCast<IFilterExpression>(IFilterExpression_$type, val) !== null;
	}
	static isSchemaType(val: any): boolean {
		return typeCast<DataSourceSchemaPropertyType>(DataSourceSchemaPropertyType_$type, val) !== null;
	}
	static operation(left: IFilterExpression | string, op: FilterExpressionOperatorType, right: IFilterExpression | any): OperationFilterExpression {
		if (FilterExpression.isFilterExpression(left)) {
			let leftExpr = <IFilterExpression><any>left;
			if (FilterExpression.isFilterExpression(right)) {
				let rightExpr = <IFilterExpression><any>right;
				return new OperationFilterExpression(leftExpr, op, rightExpr);
			} else {
				return new OperationFilterExpression(leftExpr, op, right);
			}
		} else {
			let leftStr = <string>left;
			if (FilterExpression.isFilterExpression(right)) {
				let rightExpr1 = <IFilterExpression><any>right;
				return new OperationFilterExpression(leftStr, op, rightExpr1);
			} else {
				return new OperationFilterExpression(leftStr, op, right);
			}
		}
	}
	static func(func: FilterExpressionFunctionType, ...args: IFilterExpression[]): FunctionFilterExpression {
		return new FunctionFilterExpression(func, ...args);
	}
	protected updateBooleanReturn(): void {
		this._hasBooleanReturn = this.resolveHasBooleanReturn();
	}
	protected abstract resolveHasBooleanReturn(): boolean;
	static property(propertyName: string): PropertyReferenceFilterExpression {
		if (propertyName == null) {
			return null;
		}
		let expression: PropertyReferenceFilterExpression = new PropertyReferenceFilterExpression(null);
		expression.propertyReference = propertyName;
		return expression;
	}
	static nullLiteral(): LiteralFilterExpression {
		let expression: LiteralFilterExpression = new LiteralFilterExpression(null, false);
		return expression;
	}
	static literal(literal: any): LiteralFilterExpression {
		let expression: LiteralFilterExpression = new LiteralFilterExpression(literal, false);
		return expression;
	}
	static unquotedLiteral(literal: string): LiteralFilterExpression {
		let expression: LiteralFilterExpression = new LiteralFilterExpression(literal, true);
		return expression;
	}
	match(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): boolean {
		let val = this.evaluate(item, dataProvider, schema);
		return this.toBoolean(val, dataProvider, schema);
	}
	toBoolean(value: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): boolean {
		if (!this._hasBooleanReturn) {
			return this.coerceBoolean(value, dataProvider, schema);
		}
		return <boolean>value;
	}
	private coerceBoolean(value: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): boolean {
		return Convert.toBoolean(value);
	}
	abstract evaluate(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any;
	protected get_isPropertyReference(): boolean {
		return false;
	}
	get isPropertyReference(): boolean {
		return this.get_isPropertyReference();
	}
	protected get_isOperation(): boolean {
		return false;
	}
	get isOperation(): boolean {
		return this.get_isOperation();
	}
	protected get_isFunction(): boolean {
		return false;
	}
	get isFunction(): boolean {
		return this.get_isFunction();
	}
	protected get_isLiteral(): boolean {
		return false;
	}
	get isLiteral(): boolean {
		return this.get_isLiteral();
	}
	protected get_isNull(): boolean {
		return false;
	}
	get isNull(): boolean {
		return this.get_isNull();
	}
	group(): FilterExpression {
		return FilterExpression.operation(this, FilterExpressionOperatorType.Grouping, null);
	}
	and(right: IFilterExpression): FilterExpression {
		return FilterExpression.operation(this, FilterExpressionOperatorType.And, right);
	}
	or(right: IFilterExpression): FilterExpression {
		return FilterExpression.operation(this, FilterExpressionOperatorType.Or, right);
	}
	not(): FilterExpression {
		return FilterExpression.operation(this, FilterExpressionOperatorType.Not, null);
	}
	add(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Add, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Add, right);
		}
	}
	plus(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Add, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Add, right);
		}
	}
	divide(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Divide, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Divide, right);
		}
	}
	divideBy(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Divide, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Divide, right);
		}
	}
	isEqualTo(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Equal, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Equal, right);
		}
	}
	isGreaterThan(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.GreaterThan, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.GreaterThan, right);
		}
	}
	isGreaterThanOrEqualTo(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.GreaterThanOrEqual, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.GreaterThanOrEqual, right);
		}
	}
	isLessThan(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.LessThan, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.LessThan, right);
		}
	}
	isLessThanOrEqualTo(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.LessThanOrEqual, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.LessThanOrEqual, right);
		}
	}
	modulo(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Modulo, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Modulo, right);
		}
	}
	multiply(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Multiply, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Multiply, right);
		}
	}
	times(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Multiply, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Multiply, right);
		}
	}
	isNotEqualTo(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.NotEqual, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.NotEqual, right);
		}
	}
	subtract(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Subtract, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Subtract, right);
		}
	}
	minus(right: IFilterExpression | any): FilterExpression {
		if (FilterExpression.isFilterExpression(right)) {
			let expr = <IFilterExpression><any>right;
			return FilterExpression.operation(this, FilterExpressionOperatorType.Subtract, expr);
		} else {
			return FilterExpression.operation(this, FilterExpressionOperatorType.Subtract, right);
		}
	}
	ceiling(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Ceiling, this);
	}
	concat(toAppend: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(toAppend)) {
			let expr = <IFilterExpression><any>toAppend;
			return FilterExpression.func(FilterExpressionFunctionType.Concat, this, expr);
		} else {
			let str = <string>toAppend;
			return FilterExpression.func(FilterExpressionFunctionType.Concat, this, FilterExpression.literal(str));
		}
	}
	contains(subString: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(subString)) {
			let expr = <IFilterExpression><any>subString;
			return FilterExpression.func(FilterExpressionFunctionType.Contains, this, expr);
		} else {
			let str = <string>subString;
			return FilterExpression.func(FilterExpressionFunctionType.Contains, this, FilterExpression.literal(str));
		}
	}
	day(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Day, this);
	}
	endsWith(subString: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(subString)) {
			let expr = <IFilterExpression><any>subString;
			return FilterExpression.func(FilterExpressionFunctionType.EndsWith, this, expr);
		} else {
			let str = <string>subString;
			return FilterExpression.func(FilterExpressionFunctionType.EndsWith, this, FilterExpression.literal(str));
		}
	}
	floor(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Floor, this);
	}
	hour(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Hour, this);
	}
	indexOf(toFind: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(toFind)) {
			let expr = <IFilterExpression><any>toFind;
			return FilterExpression.func(FilterExpressionFunctionType.IndexOf, this, expr);
		} else {
			let str = <string>toFind;
			return FilterExpression.func(FilterExpressionFunctionType.IndexOf, this, FilterExpression.literal(str));
		}
	}
	length(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Length1, this);
	}
	minute(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Minute, this);
	}
	month(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Month, this);
	}
	replace(toFind: IFilterExpression | string, replacement: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(toFind)) {
			let toFindExpr = <IFilterExpression><any>toFind;
			if (FilterExpression.isFilterExpression(replacement)) {
				let replacementExpr = <IFilterExpression><any>replacement;
				return FilterExpression.func(FilterExpressionFunctionType.Replace, this, toFindExpr, replacementExpr);
			} else {
				let replacementStr = <string>replacement;
				return FilterExpression.func(FilterExpressionFunctionType.Replace, this, toFindExpr, FilterExpression.literal(replacementStr));
			}
		} else {
			let toFindStr = <string>toFind;
			if (FilterExpression.isFilterExpression(replacement)) {
				let replacementExpr1 = <IFilterExpression><any>replacement;
				return FilterExpression.func(FilterExpressionFunctionType.Replace, this, FilterExpression.literal(toFindStr), replacementExpr1);
			} else {
				let replacementStr1 = <string>replacement;
				return FilterExpression.func(FilterExpressionFunctionType.Replace, this, FilterExpression.literal(toFindStr), FilterExpression.literal(replacementStr1));
			}
		}
	}
	round(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Round, this);
	}
	second(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Second, this);
	}
	startsWith(toFind: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(toFind)) {
			let expr = <IFilterExpression><any>toFind;
			return FilterExpression.func(FilterExpressionFunctionType.StartsWith, this, expr);
		} else {
			let str = <string>toFind;
			return FilterExpression.func(FilterExpressionFunctionType.StartsWith, this, FilterExpression.literal(str));
		}
	}
	substring(startIndex: IFilterExpression | number, length: IFilterExpression | number = null): FilterExpression {
		if (FilterExpression.isFilterExpression(startIndex)) {
			let startIndexExpr = <IFilterExpression><any>startIndex;
			if (length == null) {
				return FilterExpression.func(FilterExpressionFunctionType.Substring, this, startIndexExpr);
			} else {
				if (FilterExpression.isFilterExpression(length)) {
					let lengthExpr = <IFilterExpression><any>length;
					return FilterExpression.func(FilterExpressionFunctionType.Substring, this, startIndexExpr, lengthExpr);
				} else {
					let lengthInt = typeGetValue(length);
					return FilterExpression.func(FilterExpressionFunctionType.Substring, this, startIndexExpr, FilterExpression.literal(lengthInt));
				}
			}
		} else {
			let startIndexInt = typeGetValue(startIndex);
			if (length == null) {
				return FilterExpression.func(FilterExpressionFunctionType.Substring, this, FilterExpression.literal(startIndexInt));
			} else {
				if (FilterExpression.isFilterExpression(length)) {
					let lengthExpr1 = <IFilterExpression><any>length;
					return FilterExpression.func(FilterExpressionFunctionType.Substring, this, FilterExpression.literal(startIndexInt), lengthExpr1);
				} else {
					let lengthInt1 = typeGetValue(length);
					return FilterExpression.func(FilterExpressionFunctionType.Substring, this, FilterExpression.literal(startIndexInt), FilterExpression.literal(lengthInt1));
				}
			}
		}
	}
	toLower(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.ToLower, this);
	}
	toUpper(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.ToUpper, this);
	}
	trim(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Trim, this);
	}
	year(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Year, this);
	}
	date(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Date, this);
	}
	time(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Time, this);
	}
	now(): FilterExpression {
		return FilterExpression.func(FilterExpressionFunctionType.Now);
	}
	isOf(propertyType: IFilterExpression | string): FilterExpression {
		if (FilterExpression.isFilterExpression(propertyType)) {
			let expr = <IFilterExpression><any>propertyType;
			return FilterExpression.func(FilterExpressionFunctionType.IsOf, this, expr);
		} else {
			let str = <string>propertyType;
			return FilterExpression.func(FilterExpressionFunctionType.IsOf, this, FilterExpression.literal(propertyType));
		}
	}
	cast(propertyType: IFilterExpression | DataSourceSchemaPropertyType | string): FilterExpression {
		if (FilterExpression.isFilterExpression(propertyType)) {
			let expr = <IFilterExpression><any>propertyType;
			return FilterExpression.func(FilterExpressionFunctionType.Cast, this, expr);
		} else if (FilterExpression.isSchemaType(propertyType)) {
			let schemaType = EnumUtil.getEnumValue<DataSourceSchemaPropertyType>(DataSourceSchemaPropertyType_$type, propertyType);
			return FilterExpression.func(FilterExpressionFunctionType.Cast, this, FilterExpression.literal(enumGetBox<DataSourceSchemaPropertyType>(DataSourceSchemaPropertyType_$type, schemaType)));
		} else {
			let str = <string>propertyType;
			return FilterExpression.func(FilterExpressionFunctionType.Cast, this, FilterExpression.literal(str));
		}
	}
}

/**
 * @hidden 
 */
export class OperationFilterExpression extends FilterExpression implements IOperationFilterExpression {
	static $t: Type = markType(OperationFilterExpression, 'OperationFilterExpression', (<any>FilterExpression).$type, [IOperationFilterExpression_$type]);
	constructor(left: any, op: FilterExpressionOperatorType, right: any) {
		super();
		if (left != null) {
			if (FilterExpression.isFilterExpression(left)) {
				this._left = <IFilterExpression><any>left;
			} else {
				this.propertyName = <string>left;
			}
		}
		if (right != null) {
			if (FilterExpression.isFilterExpression(right)) {
				this._right = <IFilterExpression><any>right;
			} else {
				this.value = right;
			}
		}
		this._operator = op;
	}
	private _left: IFilterExpression = null;
	private _hasLeft: boolean = false;
	private _right: IFilterExpression = null;
	private _hasRight: boolean = false;
	private _operator: FilterExpressionOperatorType = FilterExpressionOperatorType.None;
	protected get_isOperation(): boolean {
		return true;
	}
	protected resolveHasBooleanReturn(): boolean {
		return this.isBooleanOperation;
	}
	get isComparisonOperation(): boolean {
		let op = this.operator;
		switch (op) {
			case FilterExpressionOperatorType.None:

			case FilterExpressionOperatorType.Equal:

			case FilterExpressionOperatorType.NotEqual:

			case FilterExpressionOperatorType.GreaterThan:

			case FilterExpressionOperatorType.LessThan:

			case FilterExpressionOperatorType.LessThanOrEqual:

			case FilterExpressionOperatorType.GreaterThanOrEqual: return true;
		}

		return false;
	}
	get propertyName(): string {
		if (this._left == null || !this._left.isPropertyReference) {
			return null;
		}
		return (<PropertyReferenceFilterExpression>this._left).propertyReference;
	}
	set propertyName(value: string) {
		this.left = FilterExpression.property(value);
	}
	get hasPropertyName(): boolean {
		return this._left != null && this._left.isPropertyReference;
	}
	get value(): any {
		if (this._right == null) {
			return null;
		}
		if (this._right.isNull) {
			return null;
		}
		if (!this._right.isLiteral) {
			return null;
		}
		return (<LiteralFilterExpression>this._right).literalValue;
	}
	set value(value: any) {
		if (value == null) {
			this.right = FilterExpression.nullLiteral();
			return;
		}
		this.right = FilterExpression.literal(value);
	}
	get hasValue(): boolean {
		return this._right != null;
	}
	get left(): IFilterExpression {
		return this._left;
	}
	set left(value: IFilterExpression) {
		this._left = value;
		this._hasLeft = true;
		this.updateBooleanReturn();
	}
	get hasLeft(): boolean {
		return this._hasLeft;
	}
	get right(): IFilterExpression {
		return this._right;
	}
	set right(value: IFilterExpression) {
		this._right = value;
		this._hasRight = true;
		this.updateBooleanReturn();
	}
	get hasRight(): boolean {
		return this._hasRight;
	}
	get operator(): FilterExpressionOperatorType {
		return this._operator;
	}
	set operator(value: FilterExpressionOperatorType) {
		this._operator = value;
		this.updateBooleanReturn();
	}
	get hasOperator(): boolean {
		return this._operator != FilterExpressionOperatorType.None;
	}
	protected get isBooleanOperation(): boolean {
		switch (this.operator) {
			case FilterExpressionOperatorType.And:

			case FilterExpressionOperatorType.Equal:

			case FilterExpressionOperatorType.GreaterThan:

			case FilterExpressionOperatorType.GreaterThanOrEqual:

			case FilterExpressionOperatorType.LessThan:

			case FilterExpressionOperatorType.LessThanOrEqual:

			case FilterExpressionOperatorType.Not:

			case FilterExpressionOperatorType.NotEqual:

			case FilterExpressionOperatorType.Or: return true;
		}

		return false;
	}
	protected get_precedence(): number {
		switch (this.operator) {
			case FilterExpressionOperatorType.Grouping: return 0;
			case FilterExpressionOperatorType.Not: return 4;
			case FilterExpressionOperatorType.Multiply: return 6;
			case FilterExpressionOperatorType.Divide: return 7;
			case FilterExpressionOperatorType.Modulo: return 8;
			case FilterExpressionOperatorType.Add: return 9;
			case FilterExpressionOperatorType.Subtract: return 10;
			case FilterExpressionOperatorType.LessThan: return 11;
			case FilterExpressionOperatorType.GreaterThan: return 12;
			case FilterExpressionOperatorType.LessThanOrEqual: return 13;
			case FilterExpressionOperatorType.GreaterThanOrEqual: return 14;
			case FilterExpressionOperatorType.Equal: return 16;
			case FilterExpressionOperatorType.NotEqual: return 17;
			case FilterExpressionOperatorType.And: return 18;
			case FilterExpressionOperatorType.Or: return 19;
			case FilterExpressionOperatorType.None: return 99;
		}

		return 99;
	}
	get precedence(): number {
		return this.get_precedence();
	}
	evaluate(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		switch (this.operator) {
			case FilterExpressionOperatorType.Add:

			case FilterExpressionOperatorType.Divide:

			case FilterExpressionOperatorType.Modulo:

			case FilterExpressionOperatorType.Multiply:

			case FilterExpressionOperatorType.Subtract: return this.evaluateArithmetic(item, dataProvider, schema);
			case FilterExpressionOperatorType.None:

			case FilterExpressionOperatorType.Equal:

			case FilterExpressionOperatorType.GreaterThan:

			case FilterExpressionOperatorType.GreaterThanOrEqual:

			case FilterExpressionOperatorType.LessThan:

			case FilterExpressionOperatorType.LessThanOrEqual:

			case FilterExpressionOperatorType.NotEqual: return this.evaluateComparison(item, dataProvider, schema);
			case FilterExpressionOperatorType.And:

			case FilterExpressionOperatorType.Not:

			case FilterExpressionOperatorType.Or: return this.evaluateLogical(item, dataProvider, schema);
			case FilterExpressionOperatorType.Grouping: if (this.left != null) {
				return this.left.evaluate(item, dataProvider, schema);
			} else {
				if (this.right == null) {
					return null;
				}
				return this.right.evaluate(item, dataProvider, schema);
			}
		}

		throw new NotImplementedException(0);
	}
	private evaluateComparison(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		let left: any = null;
		let right: any = null;
		let result: number = -1;
		if (this.left != null) {
			left = this.left.evaluate(item, dataProvider, schema);
		}
		if (this.right != null) {
			right = this.right.evaluate(item, dataProvider, schema);
		}
		if (left == null && right == null) {
			result = 0;
		}
		let leftComparable: IComparable = null;
		let rightComparable: IComparable = null;
		if (typeCast<IComparable>(IComparable_$type, left) !== null) {
			leftComparable = <IComparable><any>left;
		}
		if (typeCast<IComparable>(IComparable_$type, right) !== null) {
			rightComparable = <IComparable><any>right;
		}
		if (typeof left === 'number' && isNaN_(<number>left) || typeof right === 'number' && isNaN_(<number>right) || typeof left === 'number' && isNaN_(<number>left) || typeof right === 'number' && isNaN_(<number>right)) {
			return false;
		}
		if (leftComparable != null) {
			if (right == null) {
				result = CompareUtil.compareToObject(leftComparable, 0);
				if (result == 0) {
					result = -1;
				}
			} else {
				result = CompareUtil.compareToObject(leftComparable, right);
			}
		} else if (rightComparable != null) {
			if (left == null) {
				let other = CompareUtil.compareToObject(rightComparable, 0);
				if (other == 0) {
					result = 1;
				} else {
					result = 1;
					if (other == 0) {
						result = 0;
					}
					if (other > 0) {
						result = -1;
					}
				}
			} else {
				let other1 = CompareUtil.compareToObject(rightComparable, left);
				result = 1;
				if (other1 == 0) {
					result = 0;
				}
				if (other1 > 0) {
					result = -1;
				}
			}
		} else {
			let leftString: string = null;
			let rightString: string = null;
			if (left != null) {
				leftString = left.toString();
			}
			if (right != null) {
				rightString = right.toString();
			}
			if (leftString != null) {
				if (rightString == null) {
					result = 1;
				} else {
					result = stringCompareTo(leftString, rightString);
				}
			} else if (rightString != null) {
				if (leftString == null) {
					result = -1;
				} else {
					let other2 = stringCompareTo(rightString, leftString);
					result = 1;
					if (other2 == 0) {
						result = 0;
					}
					if (other2 > 0) {
						result = -1;
					}
				}
			} else {
				result = 0;
			}
		}
		switch (this.operator) {
			case FilterExpressionOperatorType.None:

			case FilterExpressionOperatorType.Equal: return result == 0;
			case FilterExpressionOperatorType.GreaterThan: return result > 0;
			case FilterExpressionOperatorType.GreaterThanOrEqual: return result >= 0;
			case FilterExpressionOperatorType.LessThan: return result < 0;
			case FilterExpressionOperatorType.LessThanOrEqual: return result <= 0;
			case FilterExpressionOperatorType.NotEqual: return result != 0;
		}

		throw new InvalidOperationException(0);
	}
	private evaluateLogical(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		let left: any = null;
		let right: any = null;
		if (this.left != null) {
			left = this.left.evaluate(item, dataProvider, schema);
		}
		if (this.right != null) {
			right = this.right.evaluate(item, dataProvider, schema);
		}
		if (right == null && left == null) {
			return false;
		}
		if (right == null) {
			right = false;
		}
		if (left == null) {
			left = false;
		}
		switch (this.operator) {
			case FilterExpressionOperatorType.And: return <boolean>left && <boolean>right;
			case FilterExpressionOperatorType.Not: if (this.left == null) {
				return !<boolean>right;
			} else {
				return !<boolean>left;
			}
			case FilterExpressionOperatorType.Or: return <boolean>left || <boolean>right;
		}

		return false;
	}
	private evaluateArithmetic(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		let left: any = null;
		let right: any = null;
		if (this.left != null) {
			left = this.left.evaluate(item, dataProvider, schema);
		}
		if (this.right != null) {
			right = this.right.evaluate(item, dataProvider, schema);
		}
		if (left == null) {
			return right;
		}
		if (right == null) {
			return left;
		}
		if (left == null && right == null) {
			return 0;
		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return <number>left + <number>right;
				case FilterExpressionOperatorType.Divide: return <number>left / <number>right;
				case FilterExpressionOperatorType.Modulo: return <number>left % <number>right;
				case FilterExpressionOperatorType.Multiply: return <number>left * <number>right;
				case FilterExpressionOperatorType.Subtract: return <number>left - <number>right;
			}

		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return <number>left + <number>right;
				case FilterExpressionOperatorType.Divide: return <number>left / <number>right;
				case FilterExpressionOperatorType.Modulo: return <number>left % <number>right;
				case FilterExpressionOperatorType.Multiply: return <number>left * <number>right;
				case FilterExpressionOperatorType.Subtract: return <number>left - <number>right;
			}

		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return <number>left + <number>right;
				case FilterExpressionOperatorType.Divide: return <number>left / <number>right;
				case FilterExpressionOperatorType.Modulo: return <number>left % <number>right;
				case FilterExpressionOperatorType.Multiply: return <number>left * <number>right;
				case FilterExpressionOperatorType.Subtract: return <number>left - <number>right;
			}

		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return typeGetValue(left) + typeGetValue(right);
				case FilterExpressionOperatorType.Divide: return intDivide(typeGetValue(left), typeGetValue(right));
				case FilterExpressionOperatorType.Modulo: return typeGetValue(left) % typeGetValue(right);
				case FilterExpressionOperatorType.Multiply: return typeGetValue(left) * typeGetValue(right);
				case FilterExpressionOperatorType.Subtract: return typeGetValue(left) - typeGetValue(right);
			}

		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return typeGetValue(left) + typeGetValue(right);
				case FilterExpressionOperatorType.Divide: return intDivide(typeGetValue(left), typeGetValue(right));
				case FilterExpressionOperatorType.Modulo: return typeGetValue(left) % typeGetValue(right);
				case FilterExpressionOperatorType.Multiply: return typeGetValue(left) * typeGetValue(right);
				case FilterExpressionOperatorType.Subtract: return typeGetValue(left) - typeGetValue(right);
			}

		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return typeGetValue(left) + typeGetValue(right);
				case FilterExpressionOperatorType.Divide: return intDivide(typeGetValue(left), typeGetValue(right));
				case FilterExpressionOperatorType.Modulo: return typeGetValue(left) % typeGetValue(right);
				case FilterExpressionOperatorType.Multiply: return typeGetValue(left) * typeGetValue(right);
				case FilterExpressionOperatorType.Subtract: return typeGetValue(left) - typeGetValue(right);
			}

		}
		if (typeof left === 'number' || typeof right === 'number') {
			switch (this.operator) {
				case FilterExpressionOperatorType.Add: return typeGetValue(left) + typeGetValue(right);
				case FilterExpressionOperatorType.Divide: return intDivide(typeGetValue(left), typeGetValue(right));
				case FilterExpressionOperatorType.Modulo: return typeGetValue(left) % typeGetValue(right);
				case FilterExpressionOperatorType.Multiply: return typeGetValue(left) * typeGetValue(right);
				case FilterExpressionOperatorType.Subtract: return typeGetValue(left) - typeGetValue(right);
			}

		}
		throw new NotImplementedException(0);
	}
}

/**
 * @hidden 
 */
export class FunctionFilterExpression extends FilterExpression implements IFunctionFilterExpression {
	static $t: Type = markType(FunctionFilterExpression, 'FunctionFilterExpression', (<any>FilterExpression).$type, [IFunctionFilterExpression_$type]);
	constructor($function: FilterExpressionFunctionType, ...args: IFilterExpression[]) {
		super();
		this._function = $function;
		for (let i = 0; i < args.length; i++) {
			this._functionArguments.add(args[i]);
		}
	}
	private _function: FilterExpressionFunctionType = FilterExpressionFunctionType.Ceiling;
	private _functionArguments: FilterExpressionCollection = new FilterExpressionCollection();
	protected get_isFunction(): boolean {
		return true;
	}
	protected resolveHasBooleanReturn(): boolean {
		return this.isBooleanFunction;
	}
	get functionType(): FilterExpressionFunctionType {
		return this._function;
	}
	set functionType(value: FilterExpressionFunctionType) {
		this._function = value;
		this.updateBooleanReturn();
	}
	protected get isBooleanFunction(): boolean {
		switch (this.functionType) {
			case FilterExpressionFunctionType.EndsWith:

			case FilterExpressionFunctionType.StartsWith:

			case FilterExpressionFunctionType.Contains: return true;
		}

		return false;
	}
	get functionArguments(): FilterExpressionCollection {
		return this._functionArguments;
	}
	get hasFunctionArguments(): boolean {
		return this._functionArguments.all.count > 0;
	}
	evaluate(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		let param1: any = null;
		let param2: any = null;
		let param3: any = null;
		let param4: any = null;
		let expressions = this.functionArguments.all;
		if (expressions.count > 0) {
			for (let i = 0; i < expressions.count; i++) {
				let currValue: any = null;
				if (expressions.item(i) != null) {
					currValue = expressions.item(i).evaluate(item, dataProvider, schema);
				}
				switch (i) {
					case 0:
					param1 = currValue;
					break;

					case 1:
					param2 = currValue;
					break;

					case 2:
					param3 = currValue;
					break;

					case 3:
					param4 = currValue;
					break;

				}

				if (i > 3) {
					break;
				}
			}
		}
		switch (this.functionType) {
			case FilterExpressionFunctionType.Ceiling:
			if (param1 == null) {
				param1 = 0;
			}
			return Math.ceil(<number>param1);

			case FilterExpressionFunctionType.Floor:
			if (param1 == null) {
				param1 = 0;
			}
			return Math.floor(<number>param1);

			case FilterExpressionFunctionType.Round:
			if (param1 == null) {
				param1 = 0;
			}
			if (typeof param1 === 'number') {
				return Math.round(<number>param1);
			}
			return <number>Math.round(<number>param1);

			case FilterExpressionFunctionType.Day:
			if (param1 == null) {
				return 0;
			}
			return (<Date>param1).getDate();

			case FilterExpressionFunctionType.Hour:
			if (param1 == null) {
				return 0;
			}
			return (<Date>param1).getHours();

			case FilterExpressionFunctionType.Minute:
			if (param1 == null) {
				return 0;
			}
			return (<Date>param1).getMinutes();

			case FilterExpressionFunctionType.Month:
			if (param1 == null) {
				return 0;
			}
			return dateGetMonth((<Date>param1));

			case FilterExpressionFunctionType.Year:
			if (param1 == null) {
				return 0;
			}
			return (<Date>param1).getFullYear();

			case FilterExpressionFunctionType.Second:
			if (param1 == null) {
				return 0;
			}
			return (<Date>param1).getSeconds();

			case FilterExpressionFunctionType.Date:
			if (param1 == null) {
				return 0;
			}
			return dateGetDate((<Date>param1));

			case FilterExpressionFunctionType.Time:
			if (param1 == null) {
				return 0;
			}
			return (<Date>param1);

			case FilterExpressionFunctionType.Now: return dateNow();
			case FilterExpressionFunctionType.IsOf:
			let targetType = this.getTargetType(param2, param3);
			let val = param1;
			if (val == null) {
				return true;
			}
			if (targetType == null) {
				return false;
			}
			if (targetType.isAssignableFrom(getInstanceType(val))) {
				return true;
			}
			return false;

			case FilterExpressionFunctionType.Cast:
			let targetType2 = this.getTargetType(param2, param1);
			let val2 = param1;
			if (val2 == null) {
				return true;
			}
			if (targetType2 == null) {
				return false;
			}
			return this.coerceType(val2, targetType2);

			case FilterExpressionFunctionType.Concat:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = "";
			}
			return stringConcat(<string>param1, <string>param2);

			case FilterExpressionFunctionType.EndsWith:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = "";
			}
			return stringEndsWith((<string>param1), <string>param2);

			case FilterExpressionFunctionType.IndexOf:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = "";
			}
			return (<string>param1).indexOf(<string>param2);

			case FilterExpressionFunctionType.Length1:
			if (param1 == null) {
				param1 = "";
			}
			return (<string>param1).length;

			case FilterExpressionFunctionType.Replace:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = "";
			}
			if (param3 == null) {
				param3 = "";
			}
			return stringReplace((<string>param1), <string>param2, <string>param3);

			case FilterExpressionFunctionType.StartsWith:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = "";
			}
			return stringStartsWith((<string>param1), <string>param2);

			case FilterExpressionFunctionType.Substring:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = 0;
			}
			if (param3 != null) {
				return (<string>param1).substr(typeGetValue(param2), typeGetValue(param3));
			} else {
				return (<string>param1).substr(typeGetValue(param2));
			}

			case FilterExpressionFunctionType.Contains:
			if (param1 == null) {
				param1 = "";
			}
			if (param2 == null) {
				param2 = "";
			}
			return stringContains((<string>param1), <string>param2);

			case FilterExpressionFunctionType.ToLower:
			if (param1 == null) {
				param1 = "";
			}
			return (<string>param1).toLowerCase();

			case FilterExpressionFunctionType.ToUpper:
			if (param1 == null) {
				param1 = "";
			}
			return (<string>param1).toUpperCase();

			case FilterExpressionFunctionType.Trim:
			if (param1 == null) {
				param1 = "";
			}
			return (<string>param1).trim();

		}

		throw new NotImplementedException(0);
	}
	protected get_precedence(): number {
		switch (this.functionType) {
			case FilterExpressionFunctionType.IsOf: return 15;
			case FilterExpressionFunctionType.Cast: return 5;
		}

		return 2;
	}
	get precedence(): number {
		return this.get_precedence();
	}
	private coerceType(val: any, targetType: Type): any {
		if (targetType == String_$type) {
			if (val == null) {
				return "";
			}
			return val.toString();
		} else if (targetType == Number_$type || targetType == Number_$type || targetType == Number_$type) {
			return Convert.toInt321(val);
		} else if (targetType == Boolean_$type) {
			return Convert.toBoolean(val);
		} else if (targetType == Number_$type) {
			return Convert.toByte1(val);
		} else if (targetType == Date_$type) {
			return Convert.toDateTime(val);
		} else if (targetType == Number_$type || targetType == Number_$type) {
			return Convert.toInt64(val);
		} else if (targetType == Number_$type) {
			return Convert.toDecimal2(val);
		} else {
			return val;
		}
	}
	private getTargetType(propertyType: any, literalValue: any): Type {
		if (typeCast<DataSourceSchemaPropertyType>(DataSourceSchemaPropertyType_$type, propertyType) !== null || typeof propertyType === 'number') {
			let prop: DataSourceSchemaPropertyType = <DataSourceSchemaPropertyType>typeGetValue(propertyType);
			switch (prop) {
				case DataSourceSchemaPropertyType.BooleanValue: return Boolean_$type;
				case DataSourceSchemaPropertyType.ByteValue: return Number_$type;
				case DataSourceSchemaPropertyType.DateTimeOffsetValue: return Date_$type;
				case DataSourceSchemaPropertyType.DateTimeValue: return Date_$type;
				case DataSourceSchemaPropertyType.DecimalValue: return Number_$type;
				case DataSourceSchemaPropertyType.DoubleValue: return Number_$type;
				case DataSourceSchemaPropertyType.IntValue: return Number_$type;
				case DataSourceSchemaPropertyType.LongValue: return Number_$type;
				case DataSourceSchemaPropertyType.ObjectValue:
				if (literalValue != null && typeof literalValue === 'string') {
					return this.getLiteralTargetType(<string>literalValue);
				}
				return (<any>Base).$type;

				case DataSourceSchemaPropertyType.ShortValue: return Number_$type;
				case DataSourceSchemaPropertyType.SingleValue: return Number_$type;
				case DataSourceSchemaPropertyType.StringValue: return String_$type;
			}

		}
		if (typeof propertyType === 'string') {
			return this.getLiteralTargetType(<string>literalValue);
		}
		return (<any>Base).$type;
	}
	private getLiteralTargetType(literalValue: string): Type {
		switch (literalValue) {
			case "Edm.Boolean":

			case "Boolean":

			case "bool":

			case "boolean": return Boolean_$type;
			case "Edm.Byte":

			case "Byte":

			case "byte":

			case "Edm.SByte":

			case "SByte": return Number_$type;
			case "Edm.DateTimeOffset":

			case "DateTimeOffset": return Date_$type;
			case "Edm.DateTime":

			case "DateTime":

			case "Calendar":

			case "datetime":

			case "calendar":

			case "Edm.Time":

			case "Time":

			case "time": return Date_$type;
			case "Edm.Decimal":

			case "Decimal":

			case "decimal": return Number_$type;
			case "Edm.Double":

			case "Double":

			case "double": return Number_$type;
			case "Edm.Float":

			case "Float":

			case "float":

			case "Edm.Single":

			case "Single":

			case "single": return Number_$type;
			case "Edm.Int16":

			case "Int16":

			case "Short":

			case "short": return Number_$type;
			case "Edm.Int32":

			case "Int32":

			case "int":

			case "Integer": return Number_$type;
			case "Edm.Int64":

			case "Int64":

			case "long":

			case "Long": return Number_$type;
			case "Edm.String":

			case "String":

			case "string": return String_$type;
		}

		return (<any>Base).$type;
	}
}

/**
 * @hidden 
 */
export class PropertyReferenceFilterExpression extends FilterExpression implements IPropertyReferenceFilterExpression {
	static $t: Type = markType(PropertyReferenceFilterExpression, 'PropertyReferenceFilterExpression', (<any>FilterExpression).$type, [IPropertyReferenceFilterExpression_$type]);
	constructor(propertyReference: string) {
		super();
		this._propertyReference = propertyReference;
	}
	protected get_isPropertyReference(): boolean {
		return true;
	}
	protected get_precedence(): number {
		return 99;
	}
	get precedence(): number {
		return this.get_precedence();
	}
	protected resolveHasBooleanReturn(): boolean {
		return false;
	}
	private _propertyReference: string = null;
	get propertyReference(): string {
		return this._propertyReference;
	}
	set propertyReference(value: string) {
		this._propertyReference = value;
	}
	evaluate(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		let propertyValue = dataProvider.getItemValue(item, this.propertyReference);
		return propertyValue;
	}
}

/**
 * @hidden 
 */
export class LiteralFilterExpression extends FilterExpression implements ILiteralFilterExpression {
	static $t: Type = markType(LiteralFilterExpression, 'LiteralFilterExpression', (<any>FilterExpression).$type, [ILiteralFilterExpression_$type]);
	constructor(literalValue: any, leaveStringUnquoted: boolean) {
		super();
		this._literalValue = literalValue;
	}
	protected get_precedence(): number {
		return 99;
	}
	get precedence(): number {
		return this.get_precedence();
	}
	private _literalValue: any = null;
	private _leaveUnquoted: boolean = false;
	protected get_isLiteral(): boolean {
		return true;
	}
	protected get_isNull(): boolean {
		return this.literalValue == null;
	}
	get literalValue(): any {
		return this._literalValue;
	}
	set literalValue(value: any) {
		this._literalValue = value;
	}
	get leaveUnquoted(): boolean {
		return this._leaveUnquoted;
	}
	set leaveUnquoted(value: boolean) {
		this._leaveUnquoted = value;
	}
	protected resolveHasBooleanReturn(): boolean {
		return typeCast<boolean>(Boolean_$type, this.literalValue) !== null;
	}
	evaluate(item: any, dataProvider: IDataSourceDataProvider, schema: IDataSourceSchema): any {
		return this.literalValue;
	}
}


